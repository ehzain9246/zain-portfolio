!function () { "use strict"; "SVGPathSeg" in window || (window.SVGPathSeg = function (t, e, i) { this.pathSegType = t, this.pathSegTypeAsLetter = e, this._owningPathSegList = i }, window.SVGPathSeg.prototype.classname = "SVGPathSeg", window.SVGPathSeg.PATHSEG_UNKNOWN = 0, window.SVGPathSeg.PATHSEG_CLOSEPATH = 1, window.SVGPathSeg.PATHSEG_MOVETO_ABS = 2, window.SVGPathSeg.PATHSEG_MOVETO_REL = 3, window.SVGPathSeg.PATHSEG_LINETO_ABS = 4, window.SVGPathSeg.PATHSEG_LINETO_REL = 5, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9, window.SVGPathSeg.PATHSEG_ARC_ABS = 10, window.SVGPathSeg.PATHSEG_ARC_REL = 11, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19, window.SVGPathSeg.prototype._segmentChanged = function () { this._owningPathSegList && this._owningPathSegList.segmentChanged(this) }, window.SVGPathSegClosePath = function (t) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CLOSEPATH, "z", t) }, window.SVGPathSegClosePath.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegClosePath.prototype.toString = function () { return "[object SVGPathSegClosePath]" }, window.SVGPathSegClosePath.prototype._asPathString = function () { return this.pathSegTypeAsLetter }, window.SVGPathSegClosePath.prototype.clone = function () { return new window.SVGPathSegClosePath(void 0) }, window.SVGPathSegMovetoAbs = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_ABS, "M", t), this._x = e, this._y = i }, window.SVGPathSegMovetoAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegMovetoAbs.prototype.toString = function () { return "[object SVGPathSegMovetoAbs]" }, window.SVGPathSegMovetoAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegMovetoAbs.prototype.clone = function () { return new window.SVGPathSegMovetoAbs(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegMovetoRel = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_REL, "m", t), this._x = e, this._y = i }, window.SVGPathSegMovetoRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegMovetoRel.prototype.toString = function () { return "[object SVGPathSegMovetoRel]" }, window.SVGPathSegMovetoRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegMovetoRel.prototype.clone = function () { return new window.SVGPathSegMovetoRel(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegMovetoRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegMovetoRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoAbs = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_ABS, "L", t), this._x = e, this._y = i }, window.SVGPathSegLinetoAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoAbs.prototype.toString = function () { return "[object SVGPathSegLinetoAbs]" }, window.SVGPathSegLinetoAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegLinetoAbs.prototype.clone = function () { return new window.SVGPathSegLinetoAbs(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoRel = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_REL, "l", t), this._x = e, this._y = i }, window.SVGPathSegLinetoRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoRel.prototype.toString = function () { return "[object SVGPathSegLinetoRel]" }, window.SVGPathSegLinetoRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegLinetoRel.prototype.clone = function () { return new window.SVGPathSegLinetoRel(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegLinetoRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegLinetoRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoCubicAbs = function (t, e, i, o, n, s, a) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, "C", t), this._x = e, this._y = i, this._x1 = o, this._y1 = n, this._x2 = s, this._y2 = a }, window.SVGPathSegCurvetoCubicAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoCubicAbs.prototype.toString = function () { return "[object SVGPathSegCurvetoCubicAbs]" }, window.SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoCubicAbs.prototype.clone = function () { return new window.SVGPathSegCurvetoCubicAbs(void 0, this._x, this._y, this._x1, this._y1, this._x2, this._y2) }, Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x1", { get: function () { return this._x1 }, set: function (t) { this._x1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y1", { get: function () { return this._y1 }, set: function (t) { this._y1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x2", { get: function () { return this._x2 }, set: function (t) { this._x2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y2", { get: function () { return this._y2 }, set: function (t) { this._y2 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoCubicRel = function (t, e, i, o, n, s, a) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, "c", t), this._x = e, this._y = i, this._x1 = o, this._y1 = n, this._x2 = s, this._y2 = a }, window.SVGPathSegCurvetoCubicRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoCubicRel.prototype.toString = function () { return "[object SVGPathSegCurvetoCubicRel]" }, window.SVGPathSegCurvetoCubicRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoCubicRel.prototype.clone = function () { return new window.SVGPathSegCurvetoCubicRel(void 0, this._x, this._y, this._x1, this._y1, this._x2, this._y2) }, Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x1", { get: function () { return this._x1 }, set: function (t) { this._x1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y1", { get: function () { return this._y1 }, set: function (t) { this._y1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x2", { get: function () { return this._x2 }, set: function (t) { this._x2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y2", { get: function () { return this._y2 }, set: function (t) { this._y2 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoQuadraticAbs = function (t, e, i, o, n) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, "Q", t), this._x = e, this._y = i, this._x1 = o, this._y1 = n }, window.SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () { return "[object SVGPathSegCurvetoQuadraticAbs]" }, window.SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () { return new window.SVGPathSegCurvetoQuadraticAbs(void 0, this._x, this._y, this._x1, this._y1) }, Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "x1", { get: function () { return this._x1 }, set: function (t) { this._x1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "y1", { get: function () { return this._y1 }, set: function (t) { this._y1 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoQuadraticRel = function (t, e, i, o, n) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, "q", t), this._x = e, this._y = i, this._x1 = o, this._y1 = n }, window.SVGPathSegCurvetoQuadraticRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoQuadraticRel.prototype.toString = function () { return "[object SVGPathSegCurvetoQuadraticRel]" }, window.SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoQuadraticRel.prototype.clone = function () { return new window.SVGPathSegCurvetoQuadraticRel(void 0, this._x, this._y, this._x1, this._y1) }, Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "x1", { get: function () { return this._x1 }, set: function (t) { this._x1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "y1", { get: function () { return this._y1 }, set: function (t) { this._y1 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegArcAbs = function (t, e, i, o, n, s, a, r) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_ABS, "A", t), this._x = e, this._y = i, this._r1 = o, this._r2 = n, this._angle = s, this._largeArcFlag = a, this._sweepFlag = r }, window.SVGPathSegArcAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegArcAbs.prototype.toString = function () { return "[object SVGPathSegArcAbs]" }, window.SVGPathSegArcAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y }, window.SVGPathSegArcAbs.prototype.clone = function () { return new window.SVGPathSegArcAbs(void 0, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag) }, Object.defineProperty(window.SVGPathSegArcAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "r1", { get: function () { return this._r1 }, set: function (t) { this._r1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "r2", { get: function () { return this._r2 }, set: function (t) { this._r2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "angle", { get: function () { return this._angle }, set: function (t) { this._angle = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "largeArcFlag", { get: function () { return this._largeArcFlag }, set: function (t) { this._largeArcFlag = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "sweepFlag", { get: function () { return this._sweepFlag }, set: function (t) { this._sweepFlag = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegArcRel = function (t, e, i, o, n, s, a, r) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_REL, "a", t), this._x = e, this._y = i, this._r1 = o, this._r2 = n, this._angle = s, this._largeArcFlag = a, this._sweepFlag = r }, window.SVGPathSegArcRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegArcRel.prototype.toString = function () { return "[object SVGPathSegArcRel]" }, window.SVGPathSegArcRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y }, window.SVGPathSegArcRel.prototype.clone = function () { return new window.SVGPathSegArcRel(void 0, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag) }, Object.defineProperty(window.SVGPathSegArcRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "r1", { get: function () { return this._r1 }, set: function (t) { this._r1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "r2", { get: function () { return this._r2 }, set: function (t) { this._r2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "angle", { get: function () { return this._angle }, set: function (t) { this._angle = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "largeArcFlag", { get: function () { return this._largeArcFlag }, set: function (t) { this._largeArcFlag = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "sweepFlag", { get: function () { return this._sweepFlag }, set: function (t) { this._sweepFlag = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoHorizontalAbs = function (t, e) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, "H", t), this._x = e }, window.SVGPathSegLinetoHorizontalAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoHorizontalAbs.prototype.toString = function () { return "[object SVGPathSegLinetoHorizontalAbs]" }, window.SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x }, window.SVGPathSegLinetoHorizontalAbs.prototype.clone = function () { return new window.SVGPathSegLinetoHorizontalAbs(void 0, this._x) }, Object.defineProperty(window.SVGPathSegLinetoHorizontalAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoHorizontalRel = function (t, e) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, "h", t), this._x = e }, window.SVGPathSegLinetoHorizontalRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoHorizontalRel.prototype.toString = function () { return "[object SVGPathSegLinetoHorizontalRel]" }, window.SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x }, window.SVGPathSegLinetoHorizontalRel.prototype.clone = function () { return new window.SVGPathSegLinetoHorizontalRel(void 0, this._x) }, Object.defineProperty(window.SVGPathSegLinetoHorizontalRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoVerticalAbs = function (t, e) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, "V", t), this._y = e }, window.SVGPathSegLinetoVerticalAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoVerticalAbs.prototype.toString = function () { return "[object SVGPathSegLinetoVerticalAbs]" }, window.SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._y }, window.SVGPathSegLinetoVerticalAbs.prototype.clone = function () { return new window.SVGPathSegLinetoVerticalAbs(void 0, this._y) }, Object.defineProperty(window.SVGPathSegLinetoVerticalAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoVerticalRel = function (t, e) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, "v", t), this._y = e }, window.SVGPathSegLinetoVerticalRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoVerticalRel.prototype.toString = function () { return "[object SVGPathSegLinetoVerticalRel]" }, window.SVGPathSegLinetoVerticalRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._y }, window.SVGPathSegLinetoVerticalRel.prototype.clone = function () { return new window.SVGPathSegLinetoVerticalRel(void 0, this._y) }, Object.defineProperty(window.SVGPathSegLinetoVerticalRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoCubicSmoothAbs = function (t, e, i, o, n) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, "S", t), this._x = e, this._y = i, this._x2 = o, this._y2 = n }, window.SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () { return "[object SVGPathSegCurvetoCubicSmoothAbs]" }, window.SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () { return new window.SVGPathSegCurvetoCubicSmoothAbs(void 0, this._x, this._y, this._x2, this._y2) }, Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "x2", { get: function () { return this._x2 }, set: function (t) { this._x2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "y2", { get: function () { return this._y2 }, set: function (t) { this._y2 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoCubicSmoothRel = function (t, e, i, o, n) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, "s", t), this._x = e, this._y = i, this._x2 = o, this._y2 = n }, window.SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () { return "[object SVGPathSegCurvetoCubicSmoothRel]" }, window.SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () { return new window.SVGPathSegCurvetoCubicSmoothRel(void 0, this._x, this._y, this._x2, this._y2) }, Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "x2", { get: function () { return this._x2 }, set: function (t) { this._x2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "y2", { get: function () { return this._y2 }, set: function (t) { this._y2 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoQuadraticSmoothAbs = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, "T", t), this._x = e, this._y = i }, window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () { return "[object SVGPathSegCurvetoQuadraticSmoothAbs]" }, window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () { return new window.SVGPathSegCurvetoQuadraticSmoothAbs(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoQuadraticSmoothRel = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, "t", t), this._x = e, this._y = i }, window.SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () { return "[object SVGPathSegCurvetoQuadraticSmoothRel]" }, window.SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () { return new window.SVGPathSegCurvetoQuadraticSmoothRel(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathElement.prototype.createSVGPathSegClosePath = function () { return new window.SVGPathSegClosePath(void 0) }, window.SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (t, e) { return new window.SVGPathSegMovetoAbs(void 0, t, e) }, window.SVGPathElement.prototype.createSVGPathSegMovetoRel = function (t, e) { return new window.SVGPathSegMovetoRel(void 0, t, e) }, window.SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (t, e) { return new window.SVGPathSegLinetoAbs(void 0, t, e) }, window.SVGPathElement.prototype.createSVGPathSegLinetoRel = function (t, e) { return new window.SVGPathSegLinetoRel(void 0, t, e) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (t, e, i, o, n, s) { return new window.SVGPathSegCurvetoCubicAbs(void 0, t, e, i, o, n, s) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (t, e, i, o, n, s) { return new window.SVGPathSegCurvetoCubicRel(void 0, t, e, i, o, n, s) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (t, e, i, o) { return new window.SVGPathSegCurvetoQuadraticAbs(void 0, t, e, i, o) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (t, e, i, o) { return new window.SVGPathSegCurvetoQuadraticRel(void 0, t, e, i, o) }, window.SVGPathElement.prototype.createSVGPathSegArcAbs = function (t, e, i, o, n, s, a) { return new window.SVGPathSegArcAbs(void 0, t, e, i, o, n, s, a) }, window.SVGPathElement.prototype.createSVGPathSegArcRel = function (t, e, i, o, n, s, a) { return new window.SVGPathSegArcRel(void 0, t, e, i, o, n, s, a) }, window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (t) { return new window.SVGPathSegLinetoHorizontalAbs(void 0, t) }, window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (t) { return new window.SVGPathSegLinetoHorizontalRel(void 0, t) }, window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (t) { return new window.SVGPathSegLinetoVerticalAbs(void 0, t) }, window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (t) { return new window.SVGPathSegLinetoVerticalRel(void 0, t) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (t, e, i, o) { return new window.SVGPathSegCurvetoCubicSmoothAbs(void 0, t, e, i, o) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (t, e, i, o) { return new window.SVGPathSegCurvetoCubicSmoothRel(void 0, t, e, i, o) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (t, e) { return new window.SVGPathSegCurvetoQuadraticSmoothAbs(void 0, t, e) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (t, e) { return new window.SVGPathSegCurvetoQuadraticSmoothRel(void 0, t, e) }, "getPathSegAtLength" in window.SVGPathElement.prototype || (window.SVGPathElement.prototype.getPathSegAtLength = function (t) { if (void 0 === t || !isFinite(t)) throw "Invalid arguments."; var e = document.createElementNS("http://www.w3.org/2000/svg", "path"); e.setAttribute("d", this.getAttribute("d")); var i = e.pathSegList.numberOfItems - 1; if (i <= 0) return 0; do { if (e.pathSegList.removeItem(i), t > e.getTotalLength()) break; i-- } while (i > 0); return i })), "SVGPathSegList" in window && "appendItem" in window.SVGPathSegList.prototype || (window.SVGPathSegList = function (t) { this._pathElement = t, this._list = this._parsePath(this._pathElement.getAttribute("d")), this._mutationObserverConfig = { attributes: !0, attributeFilter: ["d"] }, this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this)), this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig) }, window.SVGPathSegList.prototype.classname = "SVGPathSegList", Object.defineProperty(window.SVGPathSegList.prototype, "numberOfItems", { get: function () { return this._checkPathSynchronizedToList(), this._list.length }, enumerable: !0 }), Object.defineProperty(window.SVGPathElement.prototype, "pathSegList", { get: function () { return this._pathSegList || (this._pathSegList = new window.SVGPathSegList(this)), this._pathSegList }, enumerable: !0 }), Object.defineProperty(window.SVGPathElement.prototype, "normalizedPathSegList", { get: function () { return this.pathSegList }, enumerable: !0 }), Object.defineProperty(window.SVGPathElement.prototype, "animatedPathSegList", { get: function () { return this.pathSegList }, enumerable: !0 }), Object.defineProperty(window.SVGPathElement.prototype, "animatedNormalizedPathSegList", { get: function () { return this.pathSegList }, enumerable: !0 }), window.SVGPathSegList.prototype._checkPathSynchronizedToList = function () { this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords()) }, window.SVGPathSegList.prototype._updateListFromPathMutations = function (t) { if (this._pathElement) { var e = !1; t.forEach((function (t) { "d" == t.attributeName && (e = !0) })), e && (this._list = this._parsePath(this._pathElement.getAttribute("d"))) } }, window.SVGPathSegList.prototype._writeListToPath = function () { this._pathElementMutationObserver.disconnect(), this._pathElement.setAttribute("d", window.SVGPathSegList._pathSegArrayAsString(this._list)), this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig) }, window.SVGPathSegList.prototype.segmentChanged = function (t) { this._writeListToPath() }, window.SVGPathSegList.prototype.clear = function () { this._checkPathSynchronizedToList(), this._list.forEach((function (t) { t._owningPathSegList = null })), this._list = [], this._writeListToPath() }, window.SVGPathSegList.prototype.initialize = function (t) { return this._checkPathSynchronizedToList(), this._list = [t], t._owningPathSegList = this, this._writeListToPath(), t }, window.SVGPathSegList.prototype._checkValidIndex = function (t) { if (isNaN(t) || t < 0 || t >= this.numberOfItems) throw "INDEX_SIZE_ERR" }, window.SVGPathSegList.prototype.getItem = function (t) { return this._checkPathSynchronizedToList(), this._checkValidIndex(t), this._list[t] }, window.SVGPathSegList.prototype.insertItemBefore = function (t, e) { return this._checkPathSynchronizedToList(), e > this.numberOfItems && (e = this.numberOfItems), t._owningPathSegList && (t = t.clone()), this._list.splice(e, 0, t), t._owningPathSegList = this, this._writeListToPath(), t }, window.SVGPathSegList.prototype.replaceItem = function (t, e) { return this._checkPathSynchronizedToList(), t._owningPathSegList && (t = t.clone()), this._checkValidIndex(e), this._list[e] = t, t._owningPathSegList = this, this._writeListToPath(), t }, window.SVGPathSegList.prototype.removeItem = function (t) { this._checkPathSynchronizedToList(), this._checkValidIndex(t); var e = this._list[t]; return this._list.splice(t, 1), this._writeListToPath(), e }, window.SVGPathSegList.prototype.appendItem = function (t) { return this._checkPathSynchronizedToList(), t._owningPathSegList && (t = t.clone()), this._list.push(t), t._owningPathSegList = this, this._writeListToPath(), t }, window.SVGPathSegList._pathSegArrayAsString = function (t) { var e = "", i = !0; return t.forEach((function (t) { i ? (i = !1, e += t._asPathString()) : e += " " + t._asPathString() })), e }, window.SVGPathSegList.prototype._parsePath = function (t) { if (!t || 0 == t.length) return []; var e = this, i = function () { this.pathSegList = [] }; i.prototype.appendSegment = function (t) { this.pathSegList.push(t) }; var o = function (t) { this._string = t, this._currentIndex = 0, this._endIndex = this._string.length, this._previousCommand = window.SVGPathSeg.PATHSEG_UNKNOWN, this._skipOptionalSpaces() }; o.prototype._isCurrentSpace = function () { var t = this._string[this._currentIndex]; return t <= " " && (" " == t || "\n" == t || "\t" == t || "\r" == t || "\f" == t) }, o.prototype._skipOptionalSpaces = function () { for (; this._currentIndex < this._endIndex && this._isCurrentSpace();)this._currentIndex++; return this._currentIndex < this._endIndex }, o.prototype._skipOptionalSpacesOrDelimiter = function () { return !(this._currentIndex < this._endIndex && !this._isCurrentSpace() && "," != this._string.charAt(this._currentIndex)) && (this._skipOptionalSpaces() && this._currentIndex < this._endIndex && "," == this._string.charAt(this._currentIndex) && (this._currentIndex++, this._skipOptionalSpaces()), this._currentIndex < this._endIndex) }, o.prototype.hasMoreData = function () { return this._currentIndex < this._endIndex }, o.prototype.peekSegmentType = function () { var t = this._string[this._currentIndex]; return this._pathSegTypeFromChar(t) }, o.prototype._pathSegTypeFromChar = function (t) { switch (t) { case "Z": case "z": return window.SVGPathSeg.PATHSEG_CLOSEPATH; case "M": return window.SVGPathSeg.PATHSEG_MOVETO_ABS; case "m": return window.SVGPathSeg.PATHSEG_MOVETO_REL; case "L": return window.SVGPathSeg.PATHSEG_LINETO_ABS; case "l": return window.SVGPathSeg.PATHSEG_LINETO_REL; case "C": return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS; case "c": return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL; case "Q": return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS; case "q": return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL; case "A": return window.SVGPathSeg.PATHSEG_ARC_ABS; case "a": return window.SVGPathSeg.PATHSEG_ARC_REL; case "H": return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS; case "h": return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL; case "V": return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS; case "v": return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL; case "S": return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS; case "s": return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL; case "T": return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS; case "t": return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL; default: return window.SVGPathSeg.PATHSEG_UNKNOWN } }, o.prototype._nextCommandHelper = function (t, e) { return ("+" == t || "-" == t || "." == t || t >= "0" && t <= "9") && e != window.SVGPathSeg.PATHSEG_CLOSEPATH ? e == window.SVGPathSeg.PATHSEG_MOVETO_ABS ? window.SVGPathSeg.PATHSEG_LINETO_ABS : e == window.SVGPathSeg.PATHSEG_MOVETO_REL ? window.SVGPathSeg.PATHSEG_LINETO_REL : e : window.SVGPathSeg.PATHSEG_UNKNOWN }, o.prototype.initialCommandIsMoveTo = function () { if (!this.hasMoreData()) return !0; var t = this.peekSegmentType(); return t == window.SVGPathSeg.PATHSEG_MOVETO_ABS || t == window.SVGPathSeg.PATHSEG_MOVETO_REL }, o.prototype._parseNumber = function () { var t = 0, e = 0, i = 1, o = 0, n = 1, s = 1, a = this._currentIndex; if (this._skipOptionalSpaces(), this._currentIndex < this._endIndex && "+" == this._string.charAt(this._currentIndex) ? this._currentIndex++ : this._currentIndex < this._endIndex && "-" == this._string.charAt(this._currentIndex) && (this._currentIndex++, n = -1), !(this._currentIndex == this._endIndex || (this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") && "." != this._string.charAt(this._currentIndex))) { for (var r = this._currentIndex; this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9";)this._currentIndex++; if (this._currentIndex != r) for (var l = this._currentIndex - 1, c = 1; l >= r;)e += c * (this._string.charAt(l--) - "0"), c *= 10; if (this._currentIndex < this._endIndex && "." == this._string.charAt(this._currentIndex)) { if (this._currentIndex++, this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return; for (; this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9";)i *= 10, o += (this._string.charAt(this._currentIndex) - "0") / i, this._currentIndex += 1 } if (this._currentIndex != a && this._currentIndex + 1 < this._endIndex && ("e" == this._string.charAt(this._currentIndex) || "E" == this._string.charAt(this._currentIndex)) && "x" != this._string.charAt(this._currentIndex + 1) && "m" != this._string.charAt(this._currentIndex + 1)) { if (this._currentIndex++, "+" == this._string.charAt(this._currentIndex) ? this._currentIndex++ : "-" == this._string.charAt(this._currentIndex) && (this._currentIndex++, s = -1), this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return; for (; this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9";)t *= 10, t += this._string.charAt(this._currentIndex) - "0", this._currentIndex++ } var h = e + o; if (h *= n, t && (h *= Math.pow(10, s * t)), a != this._currentIndex) return this._skipOptionalSpacesOrDelimiter(), h } }, o.prototype._parseArcFlag = function () { if (!(this._currentIndex >= this._endIndex)) { var t = !1, e = this._string.charAt(this._currentIndex++); if ("0" == e) t = !1; else { if ("1" != e) return; t = !0 } return this._skipOptionalSpacesOrDelimiter(), t } }, o.prototype.parseSegment = function () { var t = this._string[this._currentIndex], i = this._pathSegTypeFromChar(t); if (i == window.SVGPathSeg.PATHSEG_UNKNOWN) { if (this._previousCommand == window.SVGPathSeg.PATHSEG_UNKNOWN) return null; if ((i = this._nextCommandHelper(t, this._previousCommand)) == window.SVGPathSeg.PATHSEG_UNKNOWN) return null } else this._currentIndex++; switch (this._previousCommand = i, i) { case window.SVGPathSeg.PATHSEG_MOVETO_REL: return new window.SVGPathSegMovetoRel(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_MOVETO_ABS: return new window.SVGPathSegMovetoAbs(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_REL: return new window.SVGPathSegLinetoRel(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_ABS: return new window.SVGPathSegLinetoAbs(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL: return new window.SVGPathSegLinetoHorizontalRel(e, this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS: return new window.SVGPathSegLinetoHorizontalAbs(e, this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL: return new window.SVGPathSegLinetoVerticalRel(e, this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS: return new window.SVGPathSegLinetoVerticalAbs(e, this._parseNumber()); case window.SVGPathSeg.PATHSEG_CLOSEPATH: return this._skipOptionalSpaces(), new window.SVGPathSegClosePath(e); case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL: var o = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoCubicRel(e, o.x, o.y, o.x1, o.y1, o.x2, o.y2); case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS: o = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoCubicAbs(e, o.x, o.y, o.x1, o.y1, o.x2, o.y2); case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL: o = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoCubicSmoothRel(e, o.x, o.y, o.x2, o.y2); case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: o = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoCubicSmoothAbs(e, o.x, o.y, o.x2, o.y2); case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL: o = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoQuadraticRel(e, o.x, o.y, o.x1, o.y1); case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS: o = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoQuadraticAbs(e, o.x, o.y, o.x1, o.y1); case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: return new window.SVGPathSegCurvetoQuadraticSmoothRel(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: return new window.SVGPathSegCurvetoQuadraticSmoothAbs(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_ARC_REL: o = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegArcRel(e, o.x, o.y, o.x1, o.y1, o.arcAngle, o.arcLarge, o.arcSweep); case window.SVGPathSeg.PATHSEG_ARC_ABS: o = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegArcAbs(e, o.x, o.y, o.x1, o.y1, o.arcAngle, o.arcLarge, o.arcSweep); default: throw "Unknown path seg type." } }; var n = new i, s = new o(t); if (!s.initialCommandIsMoveTo()) return []; for (; s.hasMoreData();) { var a = s.parseSegment(); if (!a) return []; n.appendSegment(a) } return n.pathSegList }) }(), function (t) {
    var e; function i(t) { var e, i, o, n, s = t, a = s.data("id"), r = s.find("#premium-particles-" + a), l = {}; if (l = elementorFrontend.isEditMode() && r.length > 0 ? (i = (e = r).data("particles-style"), o = e.data("particles-zindex"), n = e.data("particles-devices"), !!i && (l.zindex = o, l.style = i, l.devices = n.split(" "), 0 !== Object.keys(l).length ? l : void 0)) : function () { var t = s.data(); return !!t.particlesStyle && (l.zindex = t.particlesZindex, l.style = t.particlesStyle, l.devices = t.particlesDevices.split(" "), 0 !== Object.keys(l).length ? l : void 0) }(), !l) return !1; var c = elementorFrontend.getCurrentDeviceMode(); -1 === l.devices.indexOf(c) && -1 !== ["desktop", "mobile", "tablet"].indexOf(c) || (s.attr("id", "premium-section-particles-" + a), tsParticles.load("premium-section-particles-" + a, l.style), s.children("canvas.tsparticles-canvas-el").css({ zIndex: l.zindex })) }
    /*!
     * Author : Matteo Bruni - https://www.matteobruni.it
     * MIT license: https://opensource.org/licenses/MIT
     * Demo / Generator : https://particles.js.org/
     * GitHub : https://www.github.com/matteobruni/tsparticles
     * How to use? : Check the GitHub README
     * v1.33.2
     */
    !function (t, e) { if ("object" == typeof exports && "object" == typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { var i = e(); for (var o in i) ("object" == typeof exports ? exports : t)[o] = i[o] } }(this, (function () { return (() => { "use strict"; var t = { d: (e, i) => { for (var o in i) t.o(i, o) && !t.o(e, o) && Object.defineProperty(e, o, { enumerable: !0, get: i[o] }) }, o: (t, e) => Object.prototype.hasOwnProperty.call(t, e), r: t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) } }, e = {}; t.r(e), t.d(e, { AbsorberClickMode: () => uo, AlterType: () => w, AnimationStatus: () => m, CanvasUtils: () => s, Circle: () => Xt, CircleWarp: () => Kt, ClickMode: () => h, CollisionMode: () => v, ColorUtils: () => n, Constants: () => ht, Container: () => so, DestroyMode: () => d, DestroyType: () => b, DivMode: () => u, DivType: () => x, EasingType: () => C, EmitterClickMode: () => po, ExternalInteractorBase: () => On, HoverMode: () => p, InlineArrangement: () => vo, InteractivityDetect: () => V, InteractorType: () => S, Main: () => bo, MoveDirection: () => a, MoveType: () => go, NumberUtils: () => i, OrbitType: () => A, OutMode: () => g, OutModeDirection: () => l, Particle: () => vi, ParticlesInteractorBase: () => Dn, Point: () => de, Rectangle: () => Yt, RotateDirection: () => r, ShapeType: () => P, SizeMode: () => y, StartValueType: () => _, ThemeMode: () => f, TiltDirection: () => c, Type: () => yo, Utils: () => o, Vector: () => G, loadFull: () => Zn, pJSDom: () => Yn, particlesJS: () => Xn, tsParticles: () => Jn }); var i = {}; t.r(i), t.d(i, { calcEasing: () => B, clamp: () => O, collisionVelocity: () => N, getDistance: () => H, getDistances: () => I, getParticleBaseVelocity: () => F, getParticleDirectionAngle: () => D, getRangeMax: () => M, getRangeMin: () => R, getRangeValue: () => E, getValue: () => L, mix: () => T, randomInRange: () => k, setRangeValue: () => z }); var o = {}; t.r(o), t.d(o, { animate: () => W, areBoundsInside: () => tt, arrayRandomIndex: () => X, calculateBounds: () => et, cancelAnimation: () => $, circleBounce: () => lt, circleBounceDataFromParticle: () => rt, deepExtend: () => it, divMode: () => at, divModeExecute: () => nt, isDivModeEnabled: () => ot, isInArray: () => Z, isPointInside: () => K, isSsr: () => Q, itemFromArray: () => Y, loadFont: () => J, rectBounce: () => ct, singleDivModeExecute: () => st }); var n = {}; t.r(n), t.d(n, { colorMix: () => Et, colorToHsl: () => vt, colorToRgb: () => pt, getHslFromAnimation: () => zt, getLinkColor: () => Rt, getLinkRandomColor: () => Mt, getRandomRgbColor: () => Gt, getStyleFromHsl: () => Tt, getStyleFromHsv: () => kt, getStyleFromRgb: () => Ot, hslToHsv: () => bt, hslToRgb: () => mt, hslaToHsva: () => St, hslaToRgba: () => wt, hsvToHsl: () => Pt, hsvToRgb: () => xt, hsvaToHsla: () => _t, hsvaToRgba: () => Ct, rgbToHsl: () => gt, rgbToHsv: () => At, rgbaToHsva: () => Vt, stringToAlpha: () => yt, stringToRgb: () => ft }); var s = {}; t.r(s), t.d(s, { clear: () => Ht, drawConnectLine: () => Nt, drawEllipse: () => Zt, drawGrabLine: () => jt, drawLinkLine: () => Dt, drawLinkTriangle: () => Ft, drawParticle: () => qt, drawParticlePlugin: () => $t, drawPlugin: () => Wt, drawShape: () => Ut, drawShapeAfterEffect: () => Qt, gradient: () => Bt, paintBase: () => It }); var a, r, l, c, h, d, u, p, v, g, y, f, m, w, b, S, P, _, x, C, A, V; !function (t) { t.bottom = "bottom", t.bottomLeft = "bottom-left", t.bottomRight = "bottom-right", t.left = "left", t.none = "none", t.right = "right", t.top = "top", t.topLeft = "top-left", t.topRight = "top-right" }(a || (a = {})), function (t) { t.clockwise = "clockwise", t.counterClockwise = "counter-clockwise", t.random = "random" }(r || (r = {})), function (t) { t.bottom = "bottom", t.left = "left", t.right = "right", t.top = "top" }(l || (l = {})), function (t) { t.clockwise = "clockwise", t.counterClockwise = "counter-clockwise", t.random = "random" }(c || (c = {})), function (t) { t.attract = "attract", t.bubble = "bubble", t.push = "push", t.remove = "remove", t.repulse = "repulse", t.pause = "pause", t.trail = "trail" }(h || (h = {})), function (t) { t.none = "none", t.split = "split" }(d || (d = {})), function (t) { t.bounce = "bounce", t.bubble = "bubble", t.repulse = "repulse" }(u || (u = {})), function (t) { t.attract = "attract", t.bounce = "bounce", t.bubble = "bubble", t.connect = "connect", t.grab = "grab", t.light = "light", t.repulse = "repulse", t.slow = "slow", t.trail = "trail" }(p || (p = {})), function (t) { t.absorb = "absorb", t.bounce = "bounce", t.destroy = "destroy" }(v || (v = {})), function (t) { t.bounce = "bounce", t.bounceHorizontal = "bounce-horizontal", t.bounceVertical = "bounce-vertical", t.none = "none", t.out = "out", t.destroy = "destroy", t.split = "split" }(g || (g = {})), function (t) { t.precise = "precise", t.percent = "percent" }(y || (y = {})), function (t) { t.any = "any", t.dark = "dark", t.light = "light" }(f || (f = {})), function (t) { t[t.increasing = 0] = "increasing", t[t.decreasing = 1] = "decreasing" }(m || (m = {})), function (t) { t.darken = "darken", t.enlighten = "enlighten" }(w || (w = {})), function (t) { t.none = "none", t.max = "max", t.min = "min" }(b || (b = {})), function (t) { t[t.External = 0] = "External", t[t.Particles = 1] = "Particles" }(S || (S = {})), function (t) { t.char = "char", t.character = "character", t.circle = "circle", t.edge = "edge", t.image = "image", t.images = "images", t.line = "line", t.polygon = "polygon", t.square = "square", t.star = "star", t.triangle = "triangle" }(P || (P = {})), function (t) { t.max = "max", t.min = "min", t.random = "random" }(_ || (_ = {})), function (t) { t.circle = "circle", t.rectangle = "rectangle" }(x || (x = {})), function (t) { t.easeOutBack = "ease-out-back", t.easeOutCirc = "ease-out-circ", t.easeOutCubic = "ease-out-cubic", t.easeOutQuad = "ease-out-quad", t.easeOutQuart = "ease-out-quart", t.easeOutQuint = "ease-out-quint", t.easeOutExpo = "ease-out-expo", t.easeOutSine = "ease-out-sine" }(C || (C = {})), function (t) { t.front = "front", t.back = "back" }(A || (A = {})), function (t) { t.canvas = "canvas", t.parent = "parent", t.window = "window" }(V || (V = {})); class G { constructor(t, e) { let i, o; if (void 0 === e) { if ("number" == typeof t) throw new Error("tsParticles - Vector not initialized correctly"); const e = t;[i, o] = [e.x, e.y] } else[i, o] = [t, e]; this.x = i, this.y = o } static clone(t) { return G.create(t.x, t.y) } static create(t, e) { return new G(t, e) } static get origin() { return G.create(0, 0) } get angle() { return Math.atan2(this.y, this.x) } set angle(t) { this.updateFromAngle(t, this.length) } get length() { return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2)) } set length(t) { this.updateFromAngle(this.angle, t) } add(t) { return G.create(this.x + t.x, this.y + t.y) } addTo(t) { this.x += t.x, this.y += t.y } sub(t) { return G.create(this.x - t.x, this.y - t.y) } subFrom(t) { this.x -= t.x, this.y -= t.y } mult(t) { return G.create(this.x * t, this.y * t) } multTo(t) { this.x *= t, this.y *= t } div(t) { return G.create(this.x / t, this.y / t) } divTo(t) { this.x /= t, this.y /= t } distanceTo(t) { return this.sub(t).length } getLengthSq() { return Math.pow(this.x, 2) + Math.pow(this.y, 2) } distanceToSq(t) { return this.sub(t).getLengthSq() } manhattanDistanceTo(t) { return Math.abs(t.x - this.x) + Math.abs(t.y - this.y) } copy() { return G.clone(this) } setTo(t) { this.x = t.x, this.y = t.y } rotate(t) { return G.create(this.x * Math.cos(t) - this.y * Math.sin(t), this.x * Math.sin(t) + this.y * Math.cos(t)) } updateFromAngle(t, e) { this.x = Math.cos(t) * e, this.y = Math.sin(t) * e } } function O(t, e, i) { return Math.min(Math.max(t, e), i) } function T(t, e, i, o) { return Math.floor((t * i + e * o) / (i + o)) } function k(t) { const e = M(t); let i = R(t); return e === i && (i = 0), Math.random() * (e - i) + i } function E(t) { return "number" == typeof t ? t : k(t) } function R(t) { return "number" == typeof t ? t : t.min } function M(t) { return "number" == typeof t ? t : t.max } function z(t, e) { if (t === e || void 0 === e && "number" == typeof t) return t; const i = R(t), o = M(t); return void 0 !== e ? { min: Math.min(i, e), max: Math.max(o, e) } : z(i, o) } function L(t) { const e = t.random, { enable: i, minimumValue: o } = "boolean" == typeof e ? { enable: e, minimumValue: 0 } : e; return E(i ? z(t.value, o) : t.value) } function I(t, e) { const i = t.x - e.x, o = t.y - e.y; return { dx: i, dy: o, distance: Math.sqrt(i * i + o * o) } } function H(t, e) { return I(t, e).distance } function D(t) { if ("number" == typeof t) return t * Math.PI / 180; switch (t) { case a.top: return -Math.PI / 2; case a.topRight: return -Math.PI / 4; case a.right: return 0; case a.bottomRight: return Math.PI / 4; case a.bottom: return Math.PI / 2; case a.bottomLeft: return 3 * Math.PI / 4; case a.left: return Math.PI; case a.topLeft: return -3 * Math.PI / 4; case a.none: default: return Math.random() * Math.PI * 2 } } function F(t) { const e = G.origin; return e.length = 1, e.angle = t, e } function N(t, e, i, o) { return G.create(t.x * (i - o) / (i + o) + 2 * e.x * o / (i + o), t.y) } function B(t, e) { switch (e) { case C.easeOutQuad: return 1 - Math.pow(1 - t, 2); case C.easeOutCubic: return 1 - Math.pow(1 - t, 3); case C.easeOutQuart: return 1 - Math.pow(1 - t, 4); case C.easeOutQuint: return 1 - Math.pow(1 - t, 5); case C.easeOutExpo: return 1 === t ? 1 : 1 - Math.pow(2, -10 * t); case C.easeOutSine: return Math.sin(t * Math.PI / 2); case C.easeOutBack: { const e = 1.70158; return 1 + (e + 1) * Math.pow(t - 1, 3) + e * Math.pow(t - 1, 2) } case C.easeOutCirc: return Math.sqrt(1 - Math.pow(t - 1, 2)); default: return t } } var j = function (t, e, i, o) { return new (i || (i = Promise))((function (n, s) { function a(t) { try { l(o.next(t)) } catch (t) { s(t) } } function r(t) { try { l(o.throw(t)) } catch (t) { s(t) } } function l(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i((function (t) { t(e) }))).then(a, r) } l((o = o.apply(t, e || [])).next()) })) }; function q(t, e, i, o, n, s) { const a = { bounced: !1 }; return e.min >= o.min && e.min <= o.max && e.max >= o.min && e.max <= o.max && (t.max >= i.min && t.max <= (i.max + i.min) / 2 && n > 0 || t.min <= i.max && t.min > (i.max + i.min) / 2 && n < 0) && (a.velocity = n * -s, a.bounced = !0), a } function U(t, e) { if (e instanceof Array) { for (const i of e) if (t.matches(i)) return !0; return !1 } return t.matches(e) } function Q() { return "undefined" == typeof window || !window } function W() { return Q() ? t => setTimeout(t) : t => (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.setTimeout)(t) } function $() { return Q() ? t => clearTimeout(t) : t => (window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.clearTimeout)(t) } function Z(t, e) { return t === e || e instanceof Array && e.indexOf(t) > -1 } function J(t) { var e, i; return j(this, void 0, void 0, (function* () { try { yield document.fonts.load(`${null !== (e = t.weight) && void 0 !== e ? e : "400"} 36px '${null !== (i = t.font) && void 0 !== i ? i : "Verdana"}'`) } catch (t) { } })) } function X(t) { return Math.floor(Math.random() * t.length) } function Y(t, e, i = !0) { return t[void 0 !== e && i ? e % t.length : X(t)] } function K(t, e, i, o) { return tt(et(t, null != i ? i : 0), e, o) } function tt(t, e, i) { let o = !0; return i && i !== l.bottom || (o = t.top < e.height), !o || i && i !== l.left || (o = t.right > 0), !o || i && i !== l.right || (o = t.left < e.width), !o || i && i !== l.top || (o = t.bottom > 0), o } function et(t, e) { return { bottom: t.y + e, left: t.x - e, right: t.x + e, top: t.y - e } } function it(t, ...e) { for (const i of e) { if (null == i) continue; if ("object" != typeof i) { t = i; continue } const e = Array.isArray(i); !e || "object" == typeof t && t && Array.isArray(t) ? e || "object" == typeof t && t && !Array.isArray(t) || (t = {}) : t = []; for (const e in i) { if ("__proto__" === e) continue; const o = i[e], n = "object" == typeof o, s = t; s[e] = n && Array.isArray(o) ? o.map((t => it(s[e], t))) : it(s[e], o) } } return t } function ot(t, e) { return e instanceof Array ? !!e.find((e => e.enable && Z(t, e.mode))) : Z(t, e.mode) } function nt(t, e, i) { if (e instanceof Array) for (const o of e) { const e = o.mode; o.enable && Z(t, e) && st(o, i) } else { const o = e.mode; e.enable && Z(t, o) && st(e, i) } } function st(t, e) { const i = t.selectors; if (i instanceof Array) for (const o of i) e(o, t); else e(i, t) } function at(t, e) { if (e && t) return t instanceof Array ? t.find((t => U(e, t.selectors))) : U(e, t.selectors) ? t : void 0 } function rt(t) { return { position: t.getPosition(), radius: t.getRadius(), mass: t.getMass(), velocity: t.velocity, factor: G.create(L(t.options.bounce.horizontal), L(t.options.bounce.vertical)) } } function lt(t, e) { const i = t.velocity.x, o = t.velocity.y, n = t.position, s = e.position; if (i * (s.x - n.x) + o * (s.y - n.y) >= 0) { const i = -Math.atan2(s.y - n.y, s.x - n.x), o = t.mass, a = e.mass, r = t.velocity.rotate(i), l = e.velocity.rotate(i), c = N(r, l, o, a), h = N(l, r, o, a), d = c.rotate(-i), u = h.rotate(-i); t.velocity.x = d.x * t.factor.x, t.velocity.y = d.y * t.factor.y, e.velocity.x = u.x * e.factor.x, e.velocity.y = u.y * e.factor.y } } function ct(t, e) { const i = et(t.getPosition(), t.getRadius()), o = q({ min: i.left, max: i.right }, { min: i.top, max: i.bottom }, { min: e.left, max: e.right }, { min: e.top, max: e.bottom }, t.velocity.x, L(t.options.bounce.horizontal)); o.bounced && (void 0 !== o.velocity && (t.velocity.x = o.velocity), void 0 !== o.position && (t.position.x = o.position)); const n = q({ min: i.top, max: i.bottom }, { min: i.left, max: i.right }, { min: e.top, max: e.bottom }, { min: e.left, max: e.right }, t.velocity.y, L(t.options.bounce.vertical)); n.bounced && (void 0 !== n.velocity && (t.velocity.y = n.velocity), void 0 !== n.position && (t.position.y = n.position)) } class ht { } function dt(t, e, i) { let o = i; return o < 0 && (o += 1), o > 1 && (o -= 1), o < 1 / 6 ? t + 6 * (e - t) * o : o < .5 ? e : o < 2 / 3 ? t + (e - t) * (2 / 3 - o) * 6 : t } function ut(t) { if (t.startsWith("rgb")) { const e = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.]+)\s*)?\)/i.exec(t); return e ? { a: e.length > 4 ? parseFloat(e[5]) : 1, b: parseInt(e[3], 10), g: parseInt(e[2], 10), r: parseInt(e[1], 10) } : void 0 } if (t.startsWith("hsl")) { const e = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i.exec(t); return e ? wt({ a: e.length > 4 ? parseFloat(e[5]) : 1, h: parseInt(e[1], 10), l: parseInt(e[3], 10), s: parseInt(e[2], 10) }) : void 0 } if (t.startsWith("hsv")) { const e = /hsva?\(\s*(\d+)°\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i.exec(t); return e ? Ct({ a: e.length > 4 ? parseFloat(e[5]) : 1, h: parseInt(e[1], 10), s: parseInt(e[2], 10), v: parseInt(e[3], 10) }) : void 0 } { const e = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, i = t.replace(e, ((t, e, i, o, n) => e + e + i + i + o + o + (void 0 !== n ? n + n : ""))), o = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(i); return o ? { a: void 0 !== o[4] ? parseInt(o[4], 16) / 255 : 1, b: parseInt(o[3], 16), g: parseInt(o[2], 16), r: parseInt(o[1], 16) } : void 0 } } function pt(t, e, i = !0) { var o, n, s; if (void 0 === t) return; const a = "string" == typeof t ? { value: t } : t; let r; if ("string" == typeof a.value) r = a.value === ht.randomColorValue ? Gt() : ft(a.value); else if (a.value instanceof Array) { r = pt({ value: Y(a.value, e, i) }) } else { const t = a.value, e = null !== (o = t.rgb) && void 0 !== o ? o : a.value; if (void 0 !== e.r) r = e; else { const e = null !== (n = t.hsl) && void 0 !== n ? n : a.value; if (void 0 !== e.h && void 0 !== e.l) r = mt(e); else { const e = null !== (s = t.hsv) && void 0 !== s ? s : a.value; void 0 !== e.h && void 0 !== e.v && (r = xt(e)) } } } return r } function vt(t, e, i = !0) { const o = pt(t, e, i); return void 0 !== o ? gt(o) : void 0 } function gt(t) { const e = t.r / 255, i = t.g / 255, o = t.b / 255, n = Math.max(e, i, o), s = Math.min(e, i, o), a = { h: 0, l: (n + s) / 2, s: 0 }; return n != s && (a.s = a.l < .5 ? (n - s) / (n + s) : (n - s) / (2 - n - s), a.h = e === n ? (i - o) / (n - s) : a.h = i === n ? 2 + (o - e) / (n - s) : 4 + (e - i) / (n - s)), a.l *= 100, a.s *= 100, a.h *= 60, a.h < 0 && (a.h += 360), a } function yt(t) { var e; return null === (e = ut(t)) || void 0 === e ? void 0 : e.a } function ft(t) { return ut(t) } function mt(t) { const e = { b: 0, g: 0, r: 0 }, i = { h: t.h / 360, l: t.l / 100, s: t.s / 100 }; if (0 === i.s) e.b = i.l, e.g = i.l, e.r = i.l; else { const t = i.l < .5 ? i.l * (1 + i.s) : i.l + i.s - i.l * i.s, o = 2 * i.l - t; e.r = dt(o, t, i.h + 1 / 3), e.g = dt(o, t, i.h), e.b = dt(o, t, i.h - 1 / 3) } return e.r = Math.floor(255 * e.r), e.g = Math.floor(255 * e.g), e.b = Math.floor(255 * e.b), e } function wt(t) { const e = mt(t); return { a: t.a, b: e.b, g: e.g, r: e.r } } function bt(t) { const e = t.l / 100, i = e + t.s / 100 * Math.min(e, 1 - e), o = i ? 2 * (1 - e / i) : 0; return { h: t.h, s: 100 * o, v: 100 * i } } function St(t) { const e = bt(t); return { a: t.a, h: e.h, s: e.s, v: e.v } } function Pt(t) { const e = t.v / 100, i = e * (1 - t.s / 100 / 2), o = 0 === i || 1 === i ? 0 : (e - i) / Math.min(i, 1 - i); return { h: t.h, l: 100 * i, s: 100 * o } } function _t(t) { const e = Pt(t); return { a: t.a, h: e.h, l: e.l, s: e.s } } function xt(t) { const e = { b: 0, g: 0, r: 0 }, i = t.h / 60, o = t.s / 100, n = t.v / 100, s = n * o, a = s * (1 - Math.abs(i % 2 - 1)); let r; if (i >= 0 && i <= 1 ? r = { r: s, g: a, b: 0 } : i > 1 && i <= 2 ? r = { r: a, g: s, b: 0 } : i > 2 && i <= 3 ? r = { r: 0, g: s, b: a } : i > 3 && i <= 4 ? r = { r: 0, g: a, b: s } : i > 4 && i <= 5 ? r = { r: a, g: 0, b: s } : i > 5 && i <= 6 && (r = { r: s, g: 0, b: a }), r) { const t = n - s; e.r = Math.floor(255 * (r.r + t)), e.g = Math.floor(255 * (r.g + t)), e.b = Math.floor(255 * (r.b + t)) } return e } function Ct(t) { const e = xt(t); return { a: t.a, b: e.b, g: e.g, r: e.r } } function At(t) { const e = { r: t.r / 255, g: t.g / 255, b: t.b / 255 }, i = Math.max(e.r, e.g, e.b), o = i - Math.min(e.r, e.g, e.b); let n = 0; i === e.r ? n = (e.g - e.b) / o * 60 : i === e.g ? n = 60 * (2 + (e.b - e.r) / o) : i === e.b && (n = 60 * (4 + (e.r - e.g) / o)); return { h: n, s: 100 * (i ? o / i : 0), v: 100 * i } } function Vt(t) { const e = At(t); return { a: t.a, h: e.h, s: e.s, v: e.v } } function Gt(t) { const e = null != t ? t : 0; return { b: Math.floor(k(z(e, 256))), g: Math.floor(k(z(e, 256))), r: Math.floor(k(z(e, 256))) } } function Ot(t, e) { return `rgba(${t.r}, ${t.g}, ${t.b}, ${null != e ? e : 1})` } function Tt(t, e) { return `hsla(${t.h}, ${t.s}%, ${t.l}%, ${null != e ? e : 1})` } function kt(t, e) { return Tt(Pt(t), e) } function Et(t, e, i, o) { let n = t, s = e; return void 0 === n.r && (n = mt(t)), void 0 === s.r && (s = mt(e)), { b: T(n.b, s.b, i, o), g: T(n.g, s.g, i, o), r: T(n.r, s.r, i, o) } } function Rt(t, e, i) { var o, n; if (i === ht.randomColorValue) return Gt(); if ("mid" !== i) return i; { const i = null !== (o = t.getFillColor()) && void 0 !== o ? o : t.getStrokeColor(), s = null !== (n = null == e ? void 0 : e.getFillColor()) && void 0 !== n ? n : null == e ? void 0 : e.getStrokeColor(); if (i && s && e) return Et(i, s, t.getRadius(), e.getRadius()); { const t = null != i ? i : s; if (t) return mt(t) } } } function Mt(t, e, i) { const o = "string" == typeof t ? t : t.value; return o === ht.randomColorValue ? i ? pt({ value: o }) : e ? ht.randomColorValue : ht.midColorValue : pt({ value: o }) } function zt(t) { return void 0 !== t ? { h: t.h.value, s: t.s.value, l: t.l.value } : void 0 } function Lt(t, e, i) { t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(i.x, i.y), t.closePath() } function It(t, e, i) { t.save(), t.fillStyle = null != i ? i : "rgba(0,0,0,0)", t.fillRect(0, 0, e.width, e.height), t.restore() } function Ht(t, e) { t.clearRect(0, 0, e.width, e.height) } function Dt(t, e, i, o, n, s, a, r, l, c, h, d) { let u = !1; if (H(i, o) <= n) Lt(t, i, o), u = !0; else if (a) { let e, a; const r = I(i, { x: o.x - s.width, y: o.y }); if (r.distance <= n) { const t = i.y - r.dy / r.dx * i.x; e = { x: 0, y: t }, a = { x: s.width, y: t } } else { const t = I(i, { x: o.x, y: o.y - s.height }); if (t.distance <= n) { const o = -(i.y - t.dy / t.dx * i.x) / (t.dy / t.dx); e = { x: o, y: 0 }, a = { x: o, y: s.height } } else { const t = I(i, { x: o.x - s.width, y: o.y - s.height }); if (t.distance <= n) { const o = i.y - t.dy / t.dx * i.x; e = { x: -o / (t.dy / t.dx), y: o }, a = { x: e.x + s.width, y: e.y + s.height } } } } e && a && (Lt(t, i, e), Lt(t, o, a), u = !0) } if (u) { if (t.lineWidth = e, r && (t.globalCompositeOperation = l), t.strokeStyle = Ot(c, h), d.enable) { const e = pt(d.color); e && (t.shadowBlur = d.blur, t.shadowColor = Ot(e)) } t.stroke() } } function Ft(t, e, i, o, n, s, a, r) { !function (t, e, i, o) { t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(i.x, i.y), t.lineTo(o.x, o.y), t.closePath() }(t, e, i, o), n && (t.globalCompositeOperation = s), t.fillStyle = Ot(a, r), t.fill() } function Nt(t, e, i, o, n) { t.save(), Lt(t, o, n), t.lineWidth = e, t.strokeStyle = i, t.stroke(), t.restore() } function Bt(t, e, i, o) { const n = Math.floor(i.getRadius() / e.getRadius()), s = e.getFillColor(), a = i.getFillColor(); if (!s || !a) return; const r = e.getPosition(), l = i.getPosition(), c = Et(s, a, e.getRadius(), i.getRadius()), h = t.createLinearGradient(r.x, r.y, l.x, l.y); return h.addColorStop(0, Tt(s, o)), h.addColorStop(n > 1 ? 1 : n, Ot(c, o)), h.addColorStop(1, Tt(a, o)), h } function jt(t, e, i, o, n, s) { t.save(), Lt(t, i, o), t.strokeStyle = Ot(n, s), t.lineWidth = e, t.stroke(), t.restore() } function qt(t, e, i, o, n, s, a, r, l, c, h) { const d = i.getPosition(), u = i.options.tilt, p = i.options.roll; e.save(), u.enable || p.enable ? e.setTransform(p.enable ? Math.cos(i.rollAngle) : 1, u.enable ? Math.cos(i.tilt.value) * i.tilt.cosDirection : 0, u.enable ? Math.sin(i.tilt.value) * i.tilt.sinDirection : 0, p.enable ? Math.sin(i.rollAngle) : 1, d.x, d.y) : e.translate(d.x, d.y), e.beginPath(); const v = i.rotate.value + (i.options.rotate.path ? i.velocity.angle : 0); 0 !== v && e.rotate(v), a && (e.globalCompositeOperation = r); const g = i.shadowColor; h.enable && g && (e.shadowBlur = h.blur, e.shadowColor = Ot(g), e.shadowOffsetX = h.offset.x, e.shadowOffsetY = h.offset.y), n && (e.fillStyle = n); const y = i.stroke; e.lineWidth = i.strokeWidth, s && (e.strokeStyle = s), Ut(t, e, i, l, c, o), y.width > 0 && e.stroke(), i.close && e.closePath(), i.fill && e.fill(), e.restore(), e.save(), u.enable ? e.setTransform(1, Math.cos(i.tilt.value) * i.tilt.cosDirection, Math.sin(i.tilt.value) * i.tilt.sinDirection, 1, d.x, d.y) : e.translate(d.x, d.y), 0 !== v && e.rotate(v), a && (e.globalCompositeOperation = r), Qt(t, e, i, l, c, o), e.restore() } function Ut(t, e, i, o, n, s) { if (!i.shape) return; const a = t.drawers.get(i.shape); a && a.draw(e, i, o, n, s, t.retina.pixelRatio) } function Qt(t, e, i, o, n, s) { if (!i.shape) return; const a = t.drawers.get(i.shape); (null == a ? void 0 : a.afterEffect) && a.afterEffect(e, i, o, n, s, t.retina.pixelRatio) } function Wt(t, e, i) { e.draw && (t.save(), e.draw(t, i), t.restore()) } function $t(t, e, i, o) { void 0 !== e.drawParticle && (t.save(), e.drawParticle(t, i, o), t.restore()) } function Zt(t, e, i, o, n, s, a, r, l) { const c = e.getPosition(); if (i && (t.strokeStyle = Tt(i, n)), 0 === s) return; t.lineWidth = s; const h = a * Math.PI / 180; t.beginPath(), t.ellipse(c.x, c.y, o / 2, 2 * o, h, r, l), t.stroke() } ht.canvasClass = "tsparticles-canvas-el", ht.randomColorValue = "random", ht.midColorValue = "mid", ht.touchEndEvent = "touchend", ht.mouseDownEvent = "mousedown", ht.mouseUpEvent = "mouseup", ht.mouseMoveEvent = "mousemove", ht.touchStartEvent = "touchstart", ht.touchMoveEvent = "touchmove", ht.mouseLeaveEvent = "mouseleave", ht.mouseOutEvent = "mouseout", ht.touchCancelEvent = "touchcancel", ht.resizeEvent = "resize", ht.visibilityChangeEvent = "visibilitychange", ht.noPolygonDataLoaded = "No polygon data loaded.", ht.noPolygonFound = "No polygon found, you need to specify SVG url in config."; class Jt { constructor(t, e) { this.position = { x: t, y: e } } } class Xt extends Jt { constructor(t, e, i) { super(t, e), this.radius = i } contains(t) { return Math.pow(t.x - this.position.x, 2) + Math.pow(t.y - this.position.y, 2) <= this.radius * this.radius } intersects(t) { const e = t, i = t, o = this.position, n = t.position, s = Math.abs(n.x - o.x), a = Math.abs(n.y - o.y), r = this.radius; if (void 0 !== i.radius) { return r + i.radius > Math.sqrt(s * s + a + a) } if (void 0 !== e.size) { const t = e.size.width, i = e.size.height, o = Math.pow(s - t, 2) + Math.pow(a - i, 2); return !(s > r + t || a > r + i) && (s <= t || a <= i || o <= r * r) } return !1 } } class Yt extends Jt { constructor(t, e, i, o) { super(t, e), this.size = { height: o, width: i } } contains(t) { const e = this.size.width, i = this.size.height, o = this.position; return t.x >= o.x && t.x <= o.x + e && t.y >= o.y && t.y <= o.y + i } intersects(t) { const e = t, i = t, o = this.size.width, n = this.size.height, s = this.position, a = t.position; if (void 0 !== i.radius) return i.intersects(this); if (void 0 !== e.size) { const t = e.size, i = t.width, r = t.height; return a.x < s.x + o && a.x + i > s.x && a.y < s.y + n && a.y + r > s.y } return !1 } } class Kt extends Xt { constructor(t, e, i, o) { super(t, e, i), this.canvasSize = o, this.canvasSize = { height: o.height, width: o.width } } contains(t) { if (super.contains(t)) return !0; const e = { x: t.x - this.canvasSize.width, y: t.y }; if (super.contains(e)) return !0; const i = { x: t.x - this.canvasSize.width, y: t.y - this.canvasSize.height }; if (super.contains(i)) return !0; const o = { x: t.x, y: t.y - this.canvasSize.height }; return super.contains(o) } intersects(t) { if (super.intersects(t)) return !0; const e = t, i = t, o = { x: t.position.x - this.canvasSize.width, y: t.position.y - this.canvasSize.height }; if (void 0 !== i.radius) { const t = new Xt(o.x, o.y, 2 * i.radius); return super.intersects(t) } if (void 0 !== e.size) { const t = new Yt(o.x, o.y, 2 * e.size.width, 2 * e.size.height); return super.intersects(t) } return !1 } } function te(t, e, i, o, n) { if (o) { let o = { passive: !0 }; "boolean" == typeof n ? o.capture = n : void 0 !== n && (o = n), t.addEventListener(e, i, o) } else { const o = n; t.removeEventListener(e, i, o) } } class ee { constructor(t) { this.container = t, this.canPush = !0, this.mouseMoveHandler = t => this.mouseTouchMove(t), this.touchStartHandler = t => this.mouseTouchMove(t), this.touchMoveHandler = t => this.mouseTouchMove(t), this.touchEndHandler = () => this.mouseTouchFinish(), this.mouseLeaveHandler = () => this.mouseTouchFinish(), this.touchCancelHandler = () => this.mouseTouchFinish(), this.touchEndClickHandler = t => this.mouseTouchClick(t), this.mouseUpHandler = t => this.mouseTouchClick(t), this.mouseDownHandler = () => this.mouseDown(), this.visibilityChangeHandler = () => this.handleVisibilityChange(), this.resizeHandler = () => this.handleWindowResize() } addListeners() { this.manageListeners(!0) } removeListeners() { this.manageListeners(!1) } manageListeners(t) { var e; const i = this.container, o = i.actualOptions, n = o.interactivity.detectsOn; let s = ht.mouseLeaveEvent; if (n === V.window) i.interactivity.element = window, s = ht.mouseOutEvent; else if (n === V.parent && i.canvas.element) { const t = i.canvas.element; i.interactivity.element = null !== (e = t.parentElement) && void 0 !== e ? e : t.parentNode } else i.interactivity.element = i.canvas.element; const a = i.interactivity.element; if (!a) return; const r = a; (o.interactivity.events.onHover.enable || o.interactivity.events.onClick.enable) && (te(a, ht.mouseMoveEvent, this.mouseMoveHandler, t), te(a, ht.touchStartEvent, this.touchStartHandler, t), te(a, ht.touchMoveEvent, this.touchMoveHandler, t), o.interactivity.events.onClick.enable ? (te(a, ht.touchEndEvent, this.touchEndClickHandler, t), te(a, ht.mouseUpEvent, this.mouseUpHandler, t), te(a, ht.mouseDownEvent, this.mouseDownHandler, t)) : te(a, ht.touchEndEvent, this.touchEndHandler, t), te(a, s, this.mouseLeaveHandler, t), te(a, ht.touchCancelEvent, this.touchCancelHandler, t)), i.canvas.element && (i.canvas.element.style.pointerEvents = r === i.canvas.element ? "initial" : "none"), o.interactivity.events.resize && ("undefined" != typeof ResizeObserver ? this.resizeObserver && !t ? (i.canvas.element && this.resizeObserver.unobserve(i.canvas.element), this.resizeObserver.disconnect(), delete this.resizeObserver) : !this.resizeObserver && t && i.canvas.element && (this.resizeObserver = new ResizeObserver((t => { const e = t.find((t => t.target === i.canvas.element)); e && this.handleWindowResize() })), this.resizeObserver.observe(i.canvas.element)) : te(window, ht.resizeEvent, this.resizeHandler, t)), document && te(document, ht.visibilityChangeEvent, this.visibilityChangeHandler, t, !1) } handleWindowResize() { this.resizeTimeout && (clearTimeout(this.resizeTimeout), delete this.resizeTimeout), this.resizeTimeout = setTimeout((() => { var t; return null === (t = this.container.canvas) || void 0 === t ? void 0 : t.windowResize() }), 500) } handleVisibilityChange() { const t = this.container, e = t.actualOptions; this.mouseTouchFinish(), e.pauseOnBlur && ((null === document || void 0 === document ? void 0 : document.hidden) ? (t.pageHidden = !0, t.pause()) : (t.pageHidden = !1, t.getAnimationStatus() ? t.play(!0) : t.draw(!0))) } mouseDown() { const t = this.container.interactivity; if (t) { const e = t.mouse; e.clicking = !0, e.downPosition = e.position } } mouseTouchMove(t) { var e, i, o, n, s, a, r; const l = this.container, c = l.actualOptions; if (void 0 === (null === (e = l.interactivity) || void 0 === e ? void 0 : e.element)) return; let h; l.interactivity.mouse.inside = !0; const d = l.canvas.element; if (t.type.startsWith("mouse")) { this.canPush = !0; const e = t; if (l.interactivity.element === window) { if (d) { const t = d.getBoundingClientRect(); h = { x: e.clientX - t.left, y: e.clientY - t.top } } } else if (c.interactivity.detectsOn === V.parent) { const t = e.target, n = e.currentTarget, s = l.canvas.element; if (t && n && s) { const i = t.getBoundingClientRect(), o = n.getBoundingClientRect(), a = s.getBoundingClientRect(); h = { x: e.offsetX + 2 * i.left - (o.left + a.left), y: e.offsetY + 2 * i.top - (o.top + a.top) } } else h = { x: null !== (i = e.offsetX) && void 0 !== i ? i : e.clientX, y: null !== (o = e.offsetY) && void 0 !== o ? o : e.clientY } } else e.target === l.canvas.element && (h = { x: null !== (n = e.offsetX) && void 0 !== n ? n : e.clientX, y: null !== (s = e.offsetY) && void 0 !== s ? s : e.clientY }) } else { this.canPush = "touchmove" !== t.type; const e = t, i = e.touches[e.touches.length - 1], o = null == d ? void 0 : d.getBoundingClientRect(); h = { x: i.clientX - (null !== (a = null == o ? void 0 : o.left) && void 0 !== a ? a : 0), y: i.clientY - (null !== (r = null == o ? void 0 : o.top) && void 0 !== r ? r : 0) } } const u = l.retina.pixelRatio; h && (h.x *= u, h.y *= u), l.interactivity.mouse.position = h, l.interactivity.status = ht.mouseMoveEvent } mouseTouchFinish() { const t = this.container.interactivity; if (void 0 === t) return; const e = t.mouse; delete e.position, delete e.clickPosition, delete e.downPosition, t.status = ht.mouseLeaveEvent, e.inside = !1, e.clicking = !1 } mouseTouchClick(t) { const e = this.container, i = e.actualOptions, o = e.interactivity.mouse; o.inside = !0; let n = !1; const s = o.position; if (void 0 !== s && i.interactivity.events.onClick.enable) { for (const [, t] of e.plugins) if (void 0 !== t.clickPositionValid && (n = t.clickPositionValid(s), n)) break; n || this.doMouseTouchClick(t), o.clicking = !1 } } doMouseTouchClick(t) { const e = this.container, i = e.actualOptions; if (this.canPush) { const t = e.interactivity.mouse.position; if (!t) return; e.interactivity.mouse.clickPosition = { x: t.x, y: t.y }, e.interactivity.mouse.clickTime = (new Date).getTime(); const o = i.interactivity.events.onClick; if (o.mode instanceof Array) for (const t of o.mode) this.handleClickMode(t); else this.handleClickMode(o.mode) } "touchend" === t.type && setTimeout((() => this.mouseTouchFinish()), 500) } handleClickMode(t) { const e = this.container, i = e.actualOptions, o = i.interactivity.modes.push.quantity, n = i.interactivity.modes.remove.quantity; switch (t) { case h.push: if (o > 0) { const t = Y([void 0, ...i.interactivity.modes.push.groups]), n = void 0 !== t ? e.actualOptions.particles.groups[t] : void 0; e.particles.push(o, e.interactivity.mouse, n, t) } break; case h.remove: e.particles.removeQuantity(n); break; case h.bubble: e.bubble.clicking = !0; break; case h.repulse: e.repulse.clicking = !0, e.repulse.count = 0; for (const t of e.repulse.particles) t.velocity.setTo(t.initialVelocity); e.repulse.particles = [], e.repulse.finish = !1, setTimeout((() => { e.destroyed || (e.repulse.clicking = !1) }), 1e3 * i.interactivity.modes.repulse.duration); break; case h.attract: e.attract.clicking = !0, e.attract.count = 0; for (const t of e.attract.particles) t.velocity.setTo(t.initialVelocity); e.attract.particles = [], e.attract.finish = !1, setTimeout((() => { e.destroyed || (e.attract.clicking = !1) }), 1e3 * i.interactivity.modes.attract.duration); break; case h.pause: e.getAnimationStatus() ? e.pause() : e.play() }for (const [, i] of e.plugins) i.handleClickMode && i.handleClickMode(t) } } const ie = [], oe = new Map, ne = new Map, se = new Map, ae = new Map, re = new Map, le = new Map, ce = new Map; class he { static getPlugin(t) { return ie.find((e => e.id === t)) } static addPlugin(t) { he.getPlugin(t.id) || ie.push(t) } static getAvailablePlugins(t) { const e = new Map; for (const i of ie) i.needsPlugin(t.actualOptions) && e.set(i.id, i.getPlugin(t)); return e } static loadOptions(t, e) { for (const i of ie) i.loadOptions(t, e) } static getPreset(t) { return re.get(t) } static addPreset(t, e, i = !1) { !i && he.getPreset(t) || re.set(t, e) } static addShapeDrawer(t, e) { he.getShapeDrawer(t) || le.set(t, e) } static getShapeDrawer(t) { return le.get(t) } static getSupportedShapes() { return le.keys() } static getPathGenerator(t) { return ce.get(t) } static addPathGenerator(t, e) { he.getPathGenerator(t) || ce.set(t, e) } static getInteractors(t) { let e = se.get(t); return e || (e = [...oe.values()].map((e => e(t))), se.set(t, e)), e } static addInteractor(t, e) { oe.set(t, e) } static getUpdaters(t) { let e = ae.get(t); return e || (e = [...ne.values()].map((e => e(t))), ae.set(t, e)), e } static addParticleUpdater(t, e) { ne.set(t, e) } } class de { constructor(t, e) { this.position = t, this.particle = e } } class ue { constructor(t, e) { this.rectangle = t, this.capacity = e, this.points = [], this.divided = !1 } subdivide() { const t = this.rectangle.position.x, e = this.rectangle.position.y, i = this.rectangle.size.width, o = this.rectangle.size.height, n = this.capacity; this.northEast = new ue(new Yt(t, e, i / 2, o / 2), n), this.northWest = new ue(new Yt(t + i / 2, e, i / 2, o / 2), n), this.southEast = new ue(new Yt(t, e + o / 2, i / 2, o / 2), n), this.southWest = new ue(new Yt(t + i / 2, e + o / 2, i / 2, o / 2), n), this.divided = !0 } insert(t) { var e, i, o, n, s; return !!this.rectangle.contains(t.position) && (this.points.length < this.capacity ? (this.points.push(t), !0) : (this.divided || this.subdivide(), null !== (s = (null === (e = this.northEast) || void 0 === e ? void 0 : e.insert(t)) || (null === (i = this.northWest) || void 0 === i ? void 0 : i.insert(t)) || (null === (o = this.southEast) || void 0 === o ? void 0 : o.insert(t)) || (null === (n = this.southWest) || void 0 === n ? void 0 : n.insert(t))) && void 0 !== s && s)) } queryCircle(t, e) { return this.query(new Xt(t.x, t.y, e)) } queryCircleWarp(t, e, i) { const o = i, n = i; return this.query(new Kt(t.x, t.y, e, void 0 !== o.canvas ? o.canvas.size : n)) } queryRectangle(t, e) { return this.query(new Yt(t.x, t.y, e.width, e.height)) } query(t, e) { var i, o, n, s; const a = null != e ? e : []; if (!t.intersects(this.rectangle)) return []; for (const e of this.points) t.contains(e.position) && a.push(e.particle); return this.divided && (null === (i = this.northEast) || void 0 === i || i.query(t, a), null === (o = this.northWest) || void 0 === o || o.query(t, a), null === (n = this.southEast) || void 0 === n || n.query(t, a), null === (s = this.southWest) || void 0 === s || s.query(t, a)), a } } class pe { constructor(t) { this.container = t, this.size = { height: 0, width: 0 }, this.context = null, this.generatedCanvas = !1 } init() { this.resize(), this.initStyle(), this.initCover(), this.initTrail(), this.initBackground(), this.paint() } loadCanvas(t, e) { var i; t.className || (t.className = ht.canvasClass), this.generatedCanvas && (null === (i = this.element) || void 0 === i || i.remove()), this.generatedCanvas = null != e ? e : this.generatedCanvas, this.element = t, this.originalStyle = it({}, this.element.style), this.size.height = t.offsetHeight, this.size.width = t.offsetWidth, this.context = this.element.getContext("2d"), this.container.retina.init(), this.initBackground() } destroy() { var t; this.generatedCanvas && (null === (t = this.element) || void 0 === t || t.remove()), this.draw((t => { Ht(t, this.size) })) } paint() { const t = this.container.actualOptions; this.draw((e => { t.backgroundMask.enable && t.backgroundMask.cover && this.coverColor ? (Ht(e, this.size), this.paintBase(Ot(this.coverColor, this.coverColor.a))) : this.paintBase() })) } clear() { const t = this.container.actualOptions, e = t.particles.move.trail; t.backgroundMask.enable ? this.paint() : e.enable && e.length > 0 && this.trailFillColor ? this.paintBase(Ot(this.trailFillColor, 1 / e.length)) : this.draw((t => { Ht(t, this.size) })) } windowResize() { if (!this.element) return; const t = this.container; this.resize(), t.actualOptions.setResponsive(this.size.width, t.retina.pixelRatio, t.options), t.particles.setDensity(); for (const [, e] of t.plugins) void 0 !== e.resize && e.resize() } resize() { if (!this.element) return; const t = this.container, e = t.retina.pixelRatio, i = t.canvas.size, o = i.width, n = i.height; i.width = this.element.offsetWidth * e, i.height = this.element.offsetHeight * e, this.element.width = i.width, this.element.height = i.height, this.container.started && (this.resizeFactor = { width: i.width / o, height: i.height / n }) } drawConnectLine(t, e) { this.draw((i => { var o; const n = this.lineStyle(t, e); if (!n) return; const s = t.getPosition(), a = e.getPosition(); Nt(i, null !== (o = t.linksWidth) && void 0 !== o ? o : this.container.retina.linksWidth, n, s, a) })) } drawGrabLine(t, e, i, o) { const n = this.container; this.draw((s => { var a; const r = t.getPosition(); jt(s, null !== (a = t.linksWidth) && void 0 !== a ? a : n.retina.linksWidth, r, o, e, i) })) } drawParticle(t, e) { var i, o, n; if (t.spawning || t.destroyed) return; const s = t.getFillColor(), a = null !== (i = t.getStrokeColor()) && void 0 !== i ? i : s; if (!s && !a) return; let [r, l] = this.getPluginParticleColors(t); const c = t.options.twinkle.particles, h = c.enable && Math.random() < c.frequency; if (!r || !l) { const t = vt(c.color); r || (r = h && void 0 !== t ? t : s || void 0), l || (l = h && void 0 !== t ? t : a || void 0) } const d = this.container.actualOptions, u = t.options.zIndex, p = 1 - u.opacityRate * t.zIndexFactor, v = t.getRadius(), g = h ? c.opacity : null !== (o = t.bubble.opacity) && void 0 !== o ? o : t.opacity.value, y = null !== (n = t.stroke.opacity) && void 0 !== n ? n : g, f = g * p, m = r ? Tt(r, f) : void 0; if (!m && !l) return; const w = t.options.orbit; this.draw((i => { const o = 1 - u.sizeRate * t.zIndexFactor, n = l ? Tt(l, y * p) : m; v <= 0 || (w.enable && this.drawOrbit(t, A.back), qt(this.container, i, t, e, m, n, d.backgroundMask.enable, d.backgroundMask.composite, v * o, f, t.options.shadow), w.enable && this.drawOrbit(t, A.front)) })) } drawOrbit(t, e) { const i = this.container, o = t.options.orbit; let n, s; e === A.back ? (n = Math.PI / 2, s = 3 * Math.PI / 2) : e === A.front ? (n = 3 * Math.PI / 2, s = Math.PI / 2) : (n = 0, s = 2 * Math.PI), this.draw((e => { var a, r, l, c; Zt(e, t, null !== (a = t.orbitColor) && void 0 !== a ? a : t.getFillColor(), null !== (l = null !== (r = t.orbitRadius) && void 0 !== r ? r : i.retina.orbitRadius) && void 0 !== l ? l : t.getRadius(), o.opacity, o.width, (null !== (c = t.orbitRotation) && void 0 !== c ? c : 0) * i.retina.pixelRatio, n, s) })) } drawPlugin(t, e) { this.draw((i => { Wt(i, t, e) })) } drawParticlePlugin(t, e, i) { this.draw((o => { $t(o, t, e, i) })) } initBackground() { const t = this.container.actualOptions.background, e = this.element, i = null == e ? void 0 : e.style; if (i) { if (t.color) { const e = pt(t.color); i.backgroundColor = e ? Ot(e, t.opacity) : "" } else i.backgroundColor = ""; i.backgroundImage = t.image || "", i.backgroundPosition = t.position || "", i.backgroundRepeat = t.repeat || "", i.backgroundSize = t.size || "" } } draw(t) { if (this.context) return t(this.context) } initCover() { const t = this.container.actualOptions.backgroundMask.cover, e = pt(t.color); e && (this.coverColor = { r: e.r, g: e.g, b: e.b, a: t.opacity }) } initTrail() { const t = this.container.actualOptions, e = pt(t.particles.move.trail.fillColor); if (e) { const i = t.particles.move.trail; this.trailFillColor = { r: e.r, g: e.g, b: e.b, a: 1 / i.length } } } getPluginParticleColors(t) { let e, i; for (const [, o] of this.container.plugins) if (!e && o.particleFillColor && (e = vt(o.particleFillColor(t))), !i && o.particleStrokeColor && (i = vt(o.particleStrokeColor(t))), e && i) break; return [e, i] } initStyle() { const t = this.element, e = this.container.actualOptions; if (!t) return; const i = this.originalStyle; e.fullScreen.enable ? (this.originalStyle = it({}, t.style), t.style.position = "fixed", t.style.zIndex = e.fullScreen.zIndex.toString(10), t.style.top = "0", t.style.left = "0", t.style.width = "100%", t.style.height = "100%") : i && (t.style.position = i.position, t.style.zIndex = i.zIndex, t.style.top = i.top, t.style.left = i.left, t.style.width = i.width, t.style.height = i.height) } paintBase(t) { this.draw((e => { It(e, this.size, t) })) } lineStyle(t, e) { return this.draw((i => { const o = this.container.actualOptions.interactivity.modes.connect; return Bt(i, t, e, o.links.opacity) })) } } class ve { constructor() { this.value = "#fff" } static create(t, e) { const i = null != t ? t : new ve; return void 0 !== e && ("string" == typeof e || e instanceof Array ? i.load({ value: e }) : i.load(e)), i } load(t) { void 0 !== (null == t ? void 0 : t.value) && (this.value = t.value) } } class ge { constructor() { this.blur = 5, this.color = new ve, this.enable = !1, this.color.value = "#00ff00" } load(t) { void 0 !== t && (void 0 !== t.blur && (this.blur = t.blur), this.color = ve.create(this.color, t.color), void 0 !== t.enable && (this.enable = t.enable)) } } class ye { constructor() { this.enable = !1, this.frequency = 1 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = ve.create(this.color, t.color)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.frequency && (this.frequency = t.frequency), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class fe { constructor() { this.blink = !1, this.color = new ve, this.consent = !1, this.distance = 100, this.enable = !1, this.frequency = 1, this.opacity = 1, this.shadow = new ge, this.triangles = new ye, this.width = 1, this.warp = !1 } load(t) { void 0 !== t && (void 0 !== t.id && (this.id = t.id), void 0 !== t.blink && (this.blink = t.blink), this.color = ve.create(this.color, t.color), void 0 !== t.consent && (this.consent = t.consent), void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.frequency && (this.frequency = t.frequency), void 0 !== t.opacity && (this.opacity = t.opacity), this.shadow.load(t.shadow), this.triangles.load(t.triangles), void 0 !== t.width && (this.width = t.width), void 0 !== t.warp && (this.warp = t.warp)) } } class me { constructor() { this.distance = 200, this.enable = !1, this.rotate = { x: 3e3, y: 3e3 } } get rotateX() { return this.rotate.x } set rotateX(t) { this.rotate.x = t } get rotateY() { return this.rotate.y } set rotateY(t) { this.rotate.y = t } load(t) { var e, i, o, n; if (!t) return; void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.enable && (this.enable = t.enable); const s = null !== (i = null === (e = t.rotate) || void 0 === e ? void 0 : e.x) && void 0 !== i ? i : t.rotateX; void 0 !== s && (this.rotate.x = s); const a = null !== (n = null === (o = t.rotate) || void 0 === o ? void 0 : o.y) && void 0 !== n ? n : t.rotateY; void 0 !== a && (this.rotate.y = a) } } class we { constructor() { this.enable = !1, this.length = 10, this.fillColor = new ve, this.fillColor.value = "#000000" } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), this.fillColor = ve.create(this.fillColor, t.fillColor), void 0 !== t.length && (this.length = t.length)) } } class be { constructor() { this.enable = !1, this.minimumValue = 0 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.minimumValue && (this.minimumValue = t.minimumValue)) } } class Se { constructor() { this.random = new be, this.value = 0 } load(t) { t && ("boolean" == typeof t.random ? this.random.enable = t.random : this.random.load(t.random), void 0 !== t.value && (this.value = z(t.value, this.random.enable ? this.random.minimumValue : void 0))) } } class Pe extends Se { constructor() { super() } } class _e { constructor() { this.clamp = !0, this.delay = new Pe, this.enable = !1 } load(t) { void 0 !== t && (void 0 !== t.clamp && (this.clamp = t.clamp), this.delay.load(t.delay), void 0 !== t.enable && (this.enable = t.enable), this.generator = t.generator) } } class xe { constructor() { this.offset = 0, this.value = 90 } load(t) { void 0 !== t && (void 0 !== t.offset && (this.offset = t.offset), void 0 !== t.value && (this.value = t.value)) } } class Ce { constructor() { this.acceleration = 9.81, this.enable = !1, this.inverse = !1, this.maxSpeed = 50 } load(t) { t && (void 0 !== t.acceleration && (this.acceleration = t.acceleration), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.inverse && (this.inverse = t.inverse), void 0 !== t.maxSpeed && (this.maxSpeed = t.maxSpeed)) } } class Ae { constructor() { this.default = g.out } load(t) { var e, i, o, n; t && (void 0 !== t.default && (this.default = t.default), this.bottom = null !== (e = t.bottom) && void 0 !== e ? e : t.default, this.left = null !== (i = t.left) && void 0 !== i ? i : t.default, this.right = null !== (o = t.right) && void 0 !== o ? o : t.default, this.top = null !== (n = t.top) && void 0 !== n ? n : t.default) } } class Ve { constructor() { this.acceleration = 0, this.enable = !1 } load(t) { t && (void 0 !== t.acceleration && (this.acceleration = z(t.acceleration)), void 0 !== t.enable && (this.enable = t.enable), this.position = t.position ? it({}, t.position) : void 0) } } class Ge { constructor() { this.angle = new xe, this.attract = new me, this.decay = 0, this.distance = {}, this.direction = a.none, this.drift = 0, this.enable = !1, this.gravity = new Ce, this.path = new _e, this.outModes = new Ae, this.random = !1, this.size = !1, this.speed = 2, this.spin = new Ve, this.straight = !1, this.trail = new we, this.vibrate = !1, this.warp = !1 } get collisions() { return !1 } set collisions(t) { } get bounce() { return this.collisions } set bounce(t) { this.collisions = t } get out_mode() { return this.outMode } set out_mode(t) { this.outMode = t } get outMode() { return this.outModes.default } set outMode(t) { this.outModes.default = t } get noise() { return this.path } set noise(t) { this.path = t } load(t) { var e, i, o; if (void 0 === t) return; void 0 !== t.angle && ("number" == typeof t.angle ? this.angle.value = t.angle : this.angle.load(t.angle)), this.attract.load(t.attract), void 0 !== t.decay && (this.decay = t.decay), void 0 !== t.direction && (this.direction = t.direction), void 0 !== t.distance && (this.distance = "number" == typeof t.distance ? { horizontal: t.distance, vertical: t.distance } : it({}, t.distance)), void 0 !== t.drift && (this.drift = z(t.drift)), void 0 !== t.enable && (this.enable = t.enable), this.gravity.load(t.gravity); const n = null !== (e = t.outMode) && void 0 !== e ? e : t.out_mode; void 0 === t.outModes && void 0 === n || ("string" == typeof t.outModes || void 0 === t.outModes && void 0 !== n ? this.outModes.load({ default: null !== (i = t.outModes) && void 0 !== i ? i : n }) : this.outModes.load(t.outModes)), this.path.load(null !== (o = t.path) && void 0 !== o ? o : t.noise), void 0 !== t.random && (this.random = t.random), void 0 !== t.size && (this.size = t.size), void 0 !== t.speed && (this.speed = z(t.speed)), this.spin.load(t.spin), void 0 !== t.straight && (this.straight = t.straight), this.trail.load(t.trail), void 0 !== t.vibrate && (this.vibrate = t.vibrate), void 0 !== t.warp && (this.warp = t.warp) } } class Oe { constructor() { this.enable = !1, this.area = 800, this.factor = 1e3 } get value_area() { return this.area } set value_area(t) { this.area = t } load(t) { var e; if (void 0 === t) return; void 0 !== t.enable && (this.enable = t.enable); const i = null !== (e = t.area) && void 0 !== e ? e : t.value_area; void 0 !== i && (this.area = i), void 0 !== t.factor && (this.factor = t.factor) } } class Te { constructor() { this.density = new Oe, this.limit = 0, this.value = 100 } get max() { return this.limit } set max(t) { this.limit = t } load(t) { var e; if (void 0 === t) return; this.density.load(t.density); const i = null !== (e = t.limit) && void 0 !== e ? e : t.max; void 0 !== i && (this.limit = i), void 0 !== t.value && (this.value = t.value) } } class ke { constructor() { this.count = 0, this.enable = !1, this.speed = 1, this.sync = !1 } load(t) { t && (void 0 !== t.count && (this.count = t.count), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.sync && (this.sync = t.sync)) } } class Ee extends ke { constructor() { super(), this.destroy = b.none, this.enable = !1, this.minimumValue = 0, this.speed = 2, this.startValue = _.random, this.sync = !1 } get opacity_min() { return this.minimumValue } set opacity_min(t) { this.minimumValue = t } load(t) { var e; if (void 0 === t) return; super.load(t), void 0 !== t.destroy && (this.destroy = t.destroy), void 0 !== t.enable && (this.enable = t.enable); const i = null !== (e = t.minimumValue) && void 0 !== e ? e : t.opacity_min; void 0 !== i && (this.minimumValue = i), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.startValue && (this.startValue = t.startValue), void 0 !== t.sync && (this.sync = t.sync) } } class Re extends Se { constructor() { super(), this.animation = new Ee, this.random.minimumValue = .1, this.value = 1 } get anim() { return this.animation } set anim(t) { this.animation = t } load(t) { var e; if (!t) return; super.load(t); const i = null !== (e = t.animation) && void 0 !== e ? e : t.anim; void 0 !== i && (this.animation.load(i), this.value = z(this.value, this.animation.enable ? this.animation.minimumValue : void 0)) } } class Me { constructor() { this.options = {}, this.type = P.circle } get image() { var t; return null !== (t = this.options[P.image]) && void 0 !== t ? t : this.options[P.images] } set image(t) { this.options[P.image] = t, this.options[P.images] = t } get custom() { return this.options } set custom(t) { this.options = t } get images() { return this.image } set images(t) { this.image = t } get stroke() { return [] } set stroke(t) { } get character() { var t; return null !== (t = this.options[P.character]) && void 0 !== t ? t : this.options[P.char] } set character(t) { this.options[P.character] = t, this.options[P.char] = t } get polygon() { var t; return null !== (t = this.options[P.polygon]) && void 0 !== t ? t : this.options[P.star] } set polygon(t) { this.options[P.polygon] = t, this.options[P.star] = t } load(t) { var e, i, o; if (void 0 === t) return; const n = null !== (e = t.options) && void 0 !== e ? e : t.custom; if (void 0 !== n) for (const t in n) { const e = n[t]; void 0 !== e && (this.options[t] = it(null !== (i = this.options[t]) && void 0 !== i ? i : {}, e)) } this.loadShape(t.character, P.character, P.char, !0), this.loadShape(t.polygon, P.polygon, P.star, !1), this.loadShape(null !== (o = t.image) && void 0 !== o ? o : t.images, P.image, P.images, !0), void 0 !== t.type && (this.type = t.type) } loadShape(t, e, i, o) { var n, s, a, r; void 0 !== t && (t instanceof Array ? (this.options[e] instanceof Array || (this.options[e] = [], this.options[i] && !o || (this.options[i] = [])), this.options[e] = it(null !== (n = this.options[e]) && void 0 !== n ? n : [], t), this.options[i] && !o || (this.options[i] = it(null !== (s = this.options[i]) && void 0 !== s ? s : [], t))) : (this.options[e] instanceof Array && (this.options[e] = {}, this.options[i] && !o || (this.options[i] = {})), this.options[e] = it(null !== (a = this.options[e]) && void 0 !== a ? a : {}, t), this.options[i] && !o || (this.options[i] = it(null !== (r = this.options[i]) && void 0 !== r ? r : {}, t)))) } } class ze extends ke { constructor() { super(), this.destroy = b.none, this.enable = !1, this.minimumValue = 0, this.speed = 5, this.startValue = _.random, this.sync = !1 } get size_min() { return this.minimumValue } set size_min(t) { this.minimumValue = t } load(t) { var e; if (void 0 === t) return; super.load(t), void 0 !== t.destroy && (this.destroy = t.destroy), void 0 !== t.enable && (this.enable = t.enable); const i = null !== (e = t.minimumValue) && void 0 !== e ? e : t.size_min; void 0 !== i && (this.minimumValue = i), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.startValue && (this.startValue = t.startValue), void 0 !== t.sync && (this.sync = t.sync) } } class Le extends Se { constructor() { super(), this.animation = new ze, this.random.minimumValue = 1, this.value = 3 } get anim() { return this.animation } set anim(t) { this.animation = t } load(t) { var e; if (!t) return; super.load(t); const i = null !== (e = t.animation) && void 0 !== e ? e : t.anim; void 0 !== i && (this.animation.load(i), this.value = z(this.value, this.animation.enable ? this.animation.minimumValue : void 0)) } } class Ie { constructor() { this.enable = !1, this.speed = 0, this.sync = !1 } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.sync && (this.sync = t.sync)) } } class He extends Se { constructor() { super(), this.animation = new Ie, this.direction = r.clockwise, this.path = !1, this.value = 0 } load(t) { t && (super.load(t), void 0 !== t.direction && (this.direction = t.direction), this.animation.load(t.animation), void 0 !== t.path && (this.path = t.path)) } } class De { constructor() { this.blur = 0, this.color = new ve, this.enable = !1, this.offset = { x: 0, y: 0 }, this.color.value = "#000000" } load(t) { void 0 !== t && (void 0 !== t.blur && (this.blur = t.blur), this.color = ve.create(this.color, t.color), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.offset && (void 0 !== t.offset.x && (this.offset.x = t.offset.x), void 0 !== t.offset.y && (this.offset.y = t.offset.y))) } } class Fe { constructor() { this.count = 0, this.enable = !1, this.offset = 0, this.speed = 1, this.sync = !0 } load(t) { void 0 !== t && (void 0 !== t.count && (this.count = t.count), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.offset && (this.offset = z(t.offset)), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.sync && (this.sync = t.sync)) } } class Ne { constructor() { this.h = new Fe, this.s = new Fe, this.l = new Fe } load(t) { t && (this.h.load(t.h), this.s.load(t.s), this.l.load(t.l)) } } class Be extends ve { constructor() { super(), this.animation = new Ne } static create(t, e) { const i = null != t ? t : new Be; return void 0 !== e && i.load("string" == typeof e ? { value: e } : e), i } load(t) { if (super.load(t), !t) return; const e = t.animation; void 0 !== e && (void 0 !== e.enable ? this.animation.h.load(e) : this.animation.load(t.animation)) } } class je { constructor() { this.width = 0 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = Be.create(this.color, t.color)), void 0 !== t.width && (this.width = t.width), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class qe extends Se { constructor() { super(), this.random.minimumValue = .1, this.value = 1 } } class Ue { constructor() { this.horizontal = new qe, this.vertical = new qe } load(t) { t && (this.horizontal.load(t.horizontal), this.vertical.load(t.vertical)) } } class Qe { constructor() { this.enable = !0, this.retries = 0 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.retries && (this.retries = t.retries)) } } class We { constructor() { this.bounce = new Ue, this.enable = !1, this.mode = v.bounce, this.overlap = new Qe } load(t) { void 0 !== t && (this.bounce.load(t.bounce), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode), this.overlap.load(t.overlap)) } } class $e { constructor() { this.enable = !1, this.frequency = .05, this.opacity = 1 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = ve.create(this.color, t.color)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.frequency && (this.frequency = t.frequency), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class Ze { constructor() { this.lines = new $e, this.particles = new $e } load(t) { void 0 !== t && (this.lines.load(t.lines), this.particles.load(t.particles)) } } class Je extends Se { constructor() { super(), this.sync = !1 } load(t) { t && (super.load(t), void 0 !== t.sync && (this.sync = t.sync)) } } class Xe extends Se { constructor() { super(), this.random.minimumValue = 1e-4, this.sync = !1 } load(t) { void 0 !== t && (super.load(t), void 0 !== t.sync && (this.sync = t.sync)) } } class Ye { constructor() { this.count = 0, this.delay = new Je, this.duration = new Xe } load(t) { void 0 !== t && (void 0 !== t.count && (this.count = t.count), this.delay.load(t.delay), this.duration.load(t.duration)) } } class Ke extends Se { constructor() { super(), this.value = 3 } } class ti extends Se { constructor() { super(), this.value = { min: 4, max: 9 } } } class ei { constructor() { this.count = 1, this.factor = new Ke, this.rate = new ti, this.sizeOffset = !0 } load(t) { t && (void 0 !== t.count && (this.count = t.count), this.factor.load(t.factor), this.rate.load(t.rate), void 0 !== t.particles && (this.particles = it({}, t.particles)), void 0 !== t.sizeOffset && (this.sizeOffset = t.sizeOffset)) } } class ii { constructor() { this.mode = d.none, this.split = new ei } load(t) { t && (void 0 !== t.mode && (this.mode = t.mode), this.split.load(t.split)) } } class oi { constructor() { this.distance = 5, this.enable = !1, this.speed = 50 } load(t) { t && (void 0 !== t.distance && (this.distance = z(t.distance)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed && (this.speed = z(t.speed))) } } class ni { constructor() { this.enable = !1, this.speed = 0, this.sync = !1 } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.sync && (this.sync = t.sync)) } } class si extends Se { constructor() { super(), this.animation = new ni, this.direction = c.clockwise, this.enable = !1, this.value = 0 } load(t) { t && (super.load(t), this.animation.load(t.animation), void 0 !== t.direction && (this.direction = t.direction), void 0 !== t.enable && (this.enable = t.enable)) } } class ai { constructor() { this.enable = !1, this.value = 0 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.value && (this.value = t.value)) } } class ri { constructor() { this.darken = new ai, this.enable = !1, this.enlighten = new ai, this.speed = 25 } load(t) { t && (void 0 !== t.backColor && (this.backColor = ve.create(this.backColor, t.backColor)), this.darken.load(t.darken), void 0 !== t.enable && (this.enable = t.enable), this.enlighten.load(t.enlighten), void 0 !== t.speed && (this.speed = z(t.speed))) } } class li extends Se { constructor() { super(), this.opacityRate = 1, this.sizeRate = 1, this.velocityRate = 1 } load(t) { super.load(t), t && (void 0 !== t.opacityRate && (this.opacityRate = t.opacityRate), void 0 !== t.sizeRate && (this.sizeRate = t.sizeRate), void 0 !== t.velocityRate && (this.velocityRate = t.velocityRate)) } } class ci extends Se { constructor() { super(), this.value = 45, this.random.enable = !1, this.random.minimumValue = 0 } load(t) { void 0 !== t && super.load(t) } } class hi { constructor() { this.animation = new ke, this.enable = !1, this.opacity = 1, this.rotation = new ci, this.width = 1 } load(t) { void 0 !== t && (this.animation.load(t.animation), this.rotation.load(t.rotation), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.width && (this.width = t.width), void 0 !== t.radius && (this.radius = t.radius), void 0 !== t.color && (this.color = ve.create(this.color, t.color))) } } class di extends Se { constructor() { super(), this.enabled = !1, this.distance = 1, this.duration = 1, this.factor = 1, this.speed = 1 } load(t) { super.load(t), t && (void 0 !== t.enabled && (this.enabled = t.enabled), void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.speed && (this.speed = t.speed)) } } class ui { constructor() { this.bounce = new Ue, this.collisions = new We, this.color = new Be, this.destroy = new ii, this.groups = {}, this.life = new Ye, this.links = new fe, this.move = new Ge, this.number = new Te, this.opacity = new Re, this.orbit = new hi, this.reduceDuplicates = !1, this.repulse = new di, this.roll = new ri, this.rotate = new He, this.shadow = new De, this.shape = new Me, this.size = new Le, this.stroke = new je, this.tilt = new si, this.twinkle = new Ze, this.wobble = new oi, this.zIndex = new li } get line_linked() { return this.links } set line_linked(t) { this.links = t } get lineLinked() { return this.links } set lineLinked(t) { this.links = t } load(t) { var e, i, o, n, s, a, r, l; if (void 0 === t) return; this.bounce.load(t.bounce), this.color = Be.create(this.color, t.color), this.destroy.load(t.destroy), this.life.load(t.life); const c = null !== (i = null !== (e = t.links) && void 0 !== e ? e : t.lineLinked) && void 0 !== i ? i : t.line_linked; if (void 0 !== c && this.links.load(c), void 0 !== t.groups) for (const e in t.groups) { const i = t.groups[e]; void 0 !== i && (this.groups[e] = it(null !== (o = this.groups[e]) && void 0 !== o ? o : {}, i)) } this.move.load(t.move), this.number.load(t.number), this.opacity.load(t.opacity), this.orbit.load(t.orbit), void 0 !== t.reduceDuplicates && (this.reduceDuplicates = t.reduceDuplicates), this.repulse.load(t.repulse), this.roll.load(t.roll), this.rotate.load(t.rotate), this.shape.load(t.shape), this.size.load(t.size), this.shadow.load(t.shadow), this.tilt.load(t.tilt), this.twinkle.load(t.twinkle), this.wobble.load(t.wobble), this.zIndex.load(t.zIndex); const h = null !== (s = null === (n = t.move) || void 0 === n ? void 0 : n.collisions) && void 0 !== s ? s : null === (a = t.move) || void 0 === a ? void 0 : a.bounce; void 0 !== h && (this.collisions.enable = h), this.collisions.load(t.collisions); const d = null !== (r = t.stroke) && void 0 !== r ? r : null === (l = t.shape) || void 0 === l ? void 0 : l.stroke; void 0 !== d && (d instanceof Array ? this.stroke = d.map((t => { const e = new je; return e.load(t), e })) : (this.stroke instanceof Array && (this.stroke = new je), this.stroke.load(d))) } } class pi extends G { constructor(t, e, i) { super(t, e), this.z = void 0 === i ? t.z : i } static clone(t) { return pi.create(t.x, t.y, t.z) } static create(t, e, i) { return new pi(t, e, i) } add(t) { return t instanceof pi ? pi.create(this.x + t.x, this.y + t.y, this.z + t.z) : super.add(t) } addTo(t) { super.addTo(t), t instanceof pi && (this.z += t.z) } sub(t) { return t instanceof pi ? pi.create(this.x - t.x, this.y - t.y, this.z - t.z) : super.sub(t) } subFrom(t) { super.subFrom(t), t instanceof pi && (this.z -= t.z) } mult(t) { return pi.create(this.x * t, this.y * t, this.z * t) } multTo(t) { super.multTo(t), this.z *= t } div(t) { return pi.create(this.x / t, this.y / t, this.z / t) } divTo(t) { super.divTo(t), this.z /= t } copy() { return pi.clone(this) } setTo(t) { super.setTo(t), t instanceof pi && (this.z = t.z) } } class vi { constructor(t, e, i, o, n) { var s, a, l, h, d, u, p, v, g, y; this.id = t, this.container = e, this.group = n, this.fill = !0, this.close = !0, this.lastPathTime = 0, this.destroyed = !1, this.unbreakable = !1, this.splitCount = 0, this.misplaced = !1, this.loops = { opacity: 0, size: 0 }, this.maxDistance = {}; const f = e.retina.pixelRatio, b = e.actualOptions, S = new ui; S.load(b.particles); const P = S.shape.type, x = S.reduceDuplicates; if (this.shape = P instanceof Array ? Y(P, this.id, x) : P, null == o ? void 0 : o.shape) { if (o.shape.type) { const t = o.shape.type; this.shape = t instanceof Array ? Y(t, this.id, x) : t } const t = new Me; t.load(o.shape), this.shape && (this.shapeData = this.loadShapeData(t, x)) } else this.shapeData = this.loadShapeData(S.shape, x); void 0 !== o && S.load(o), void 0 !== (null === (s = this.shapeData) || void 0 === s ? void 0 : s.particles) && S.load(null === (a = this.shapeData) || void 0 === a ? void 0 : a.particles), this.fill = null !== (h = null === (l = this.shapeData) || void 0 === l ? void 0 : l.fill) && void 0 !== h ? h : this.fill, this.close = null !== (u = null === (d = this.shapeData) || void 0 === d ? void 0 : d.close) && void 0 !== u ? u : this.close, this.options = S; const C = E(this.options.zIndex.value); this.pathDelay = 1e3 * L(this.options.move.path.delay), this.wobbleDistance = 0, e.retina.initParticle(this); const A = this.options.color, V = this.options.size, T = L(V) * e.retina.pixelRatio; this.size = { value: T, max: M(V.value) * f, min: R(V.value) * f }; const I = V.animation; if (I.enable) { this.size.status = m.increasing; const t = z(V.value, I.minimumValue * f); switch (this.size.min = R(t), this.size.max = M(t), I.startValue) { case _.min: this.size.value = this.size.min, this.size.status = m.increasing; break; case _.random: this.size.value = k(this.size), this.size.status = Math.random() >= .5 ? m.increasing : m.decreasing; break; case _.max: default: this.size.value = this.size.max, this.size.status = m.decreasing }this.size.velocity = (null !== (p = this.sizeAnimationSpeed) && void 0 !== p ? p : e.retina.sizeAnimationSpeed) / 100 * e.retina.reduceFactor, I.sync || (this.size.velocity *= Math.random()) } this.direction = D(this.options.move.direction), this.bubble = { inRange: !1 }, this.initialVelocity = this.calculateVelocity(), this.velocity = this.initialVelocity.copy(); const F = this.options.rotate; this.rotate = { value: E(F.value) * Math.PI / 180 }; let N = F.direction; if (N === r.random) { N = Math.floor(2 * Math.random()) > 0 ? r.counterClockwise : r.clockwise } switch (N) { case r.counterClockwise: case "counterClockwise": this.rotate.status = m.decreasing; break; case r.clockwise: this.rotate.status = m.increasing }const B = this.options.rotate.animation; B.enable && (this.rotate.velocity = B.speed / 360 * e.retina.reduceFactor, B.sync || (this.rotate.velocity *= Math.random())); const j = this.options.tilt; this.tilt = { value: E(j.value) * Math.PI / 180, sinDirection: Math.random() >= .5 ? 1 : -1, cosDirection: Math.random() >= .5 ? 1 : -1 }; let q = j.direction; if (q === c.random) { q = Math.floor(2 * Math.random()) > 0 ? c.counterClockwise : c.clockwise } switch (q) { case c.counterClockwise: case "counterClockwise": this.tilt.status = m.decreasing; break; case c.clockwise: this.tilt.status = m.increasing }const U = this.options.tilt.animation; U.enable && (this.tilt.velocity = U.speed / 360 * e.retina.reduceFactor, U.sync || (this.tilt.velocity *= Math.random())); const Q = S.orbit; Q.enable && (this.orbitRotation = E(Q.rotation.value), this.orbitColor = vt(Q.color)); const W = vt(A, this.id, x); if (W) { this.color = { h: { value: W.h }, s: { value: W.s }, l: { value: W.l } }; const t = this.options.color.animation; this.setColorAnimation(t.h, this.color.h), this.setColorAnimation(t.s, this.color.s), this.setColorAnimation(t.l, this.color.l) } const $ = this.options.roll; $.enable ? (this.color && ($.backColor ? this.backColor = vt($.backColor) : $.darken.enable && $.enlighten.enable ? (this.alterType = Math.random() >= .5 ? w.darken : w.enlighten, this.alterValue = this.alterType === w.darken ? $.darken.value : $.enlighten.value) : $.darken.enable ? (this.alterType = w.darken, this.alterValue = $.darken.value) : $.enlighten.enable && (this.alterType = w.enlighten, this.alterValue = $.enlighten.value)), this.rollAngle = Math.random() * Math.PI * 2, this.rollSpeed = E($.speed) / 360) : (this.rollAngle = 0, this.rollSpeed = 0); const Z = this.options.wobble; Z.enable ? (this.wobbleAngle = Math.random() * Math.PI * 2, this.wobbleSpeed = E(Z.speed) / 360) : (this.wobbleAngle = 0, this.wobbleSpeed = 0), this.position = this.calcPosition(e, i, O(C, 0, e.zLayers)), this.initialPosition = this.position.copy(), this.offset = G.origin; const J = e.particles; J.needsSort = J.needsSort || J.lastZIndex < this.position.z, J.lastZIndex = this.position.z, this.zIndexFactor = this.position.z / e.zLayers; const X = this.options.opacity; this.opacity = { max: M(X.value), min: R(X.value), value: L(X) }; const K = X.animation; if (K.enable) { this.opacity.status = m.increasing; const t = z(X.value, K.minimumValue); switch (this.opacity.min = R(t), this.opacity.max = M(t), K.startValue) { case _.min: this.opacity.value = this.opacity.min, this.opacity.status = m.increasing; break; case _.random: this.opacity.value = k(this.opacity), this.opacity.status = Math.random() >= .5 ? m.increasing : m.decreasing; break; case _.max: default: this.opacity.value = this.opacity.max, this.opacity.status = m.decreasing }this.opacity.velocity = K.speed / 100 * e.retina.reduceFactor, K.sync || (this.opacity.velocity *= Math.random()) } this.sides = 24; let tt = e.drawers.get(this.shape); tt || (tt = he.getShapeDrawer(this.shape), tt && e.drawers.set(this.shape, tt)), (null == tt ? void 0 : tt.loadShape) && (null == tt || tt.loadShape(this)); const et = null == tt ? void 0 : tt.getSidesCount; et && (this.sides = et(this)), this.stroke = this.options.stroke instanceof Array ? Y(this.options.stroke, this.id, x) : this.options.stroke, this.strokeWidth = this.stroke.width * e.retina.pixelRatio; const it = null !== (v = vt(this.stroke.color)) && void 0 !== v ? v : this.getFillColor(); if (it) { this.strokeColor = { h: { value: it.h }, s: { value: it.s }, l: { value: it.l } }; const t = null === (g = this.stroke.color) || void 0 === g ? void 0 : g.animation; t && this.strokeColor && (this.setColorAnimation(t.h, this.strokeColor.h), this.setColorAnimation(t.s, this.strokeColor.s), this.setColorAnimation(t.l, this.strokeColor.l)) } if (this.life = this.loadLife(), this.spawning = this.life.delay > 0, this.options.move.spin.enable) { const t = null !== (y = this.options.move.spin.position) && void 0 !== y ? y : { x: 50, y: 50 }, i = { x: t.x / 100 * e.canvas.size.width, y: t.y / 100 * e.canvas.size.height }, o = H(this.getPosition(), i); this.spin = { center: i, direction: this.velocity.x >= 0 ? r.clockwise : r.counterClockwise, angle: this.velocity.angle, radius: o, acceleration: E(this.options.move.spin.acceleration) } } this.shadowColor = pt(this.options.shadow.color), tt && tt.particleInit && tt.particleInit(e, this); for (const [, t] of e.plugins) t.particleCreated && t.particleCreated(this) } draw(t) { const e = this.container; for (const [, i] of e.plugins) e.canvas.drawParticlePlugin(i, this, t); e.canvas.drawParticle(this, t) } getPosition() { return { x: this.position.x + this.offset.x, y: this.position.y + this.offset.y, z: this.position.z } } getRadius() { return this.bubble.radius || this.size.value } getMass() { const t = this.getRadius(); return Math.pow(t, 2) * Math.PI / 2 } getFillColor() { if (this.bubble.color) return this.bubble.color; const t = zt(this.color); if (t && (this.backColor || this.alterType && void 0 !== this.alterValue)) { if (Math.floor(this.rollAngle / (Math.PI / 2)) % 2) { if (this.backColor) return this.backColor; if (this.alterType && void 0 !== this.alterValue) return { h: t.h, s: t.s, l: t.l + (this.alterType === w.darken ? -1 : 1) * this.alterValue } } } return t } getStrokeColor() { var t, e; return null !== (e = null !== (t = this.bubble.color) && void 0 !== t ? t : zt(this.strokeColor)) && void 0 !== e ? e : this.getFillColor() } destroy(t) { if (this.destroyed = !0, this.bubble.inRange = !1, this.unbreakable) return; this.destroyed = !0, this.bubble.inRange = !1; for (const [, e] of this.container.plugins) e.particleDestroyed && e.particleDestroyed(this, t); if (t) return; this.options.destroy.mode === d.split && this.split() } reset() { this.loops.opacity = 0, this.loops.size = 0 } split() { const t = this.options.destroy.split; if (t.count >= 0 && this.splitCount++ > t.count) return; const e = E(t.rate.value); for (let t = 0; t < e; t++)this.container.particles.addSplitParticle(this) } setColorAnimation(t, e) { if (t.enable) { if (e.velocity = t.speed / 100 * this.container.retina.reduceFactor, t.sync) return; e.status = m.increasing, e.velocity *= Math.random(), e.value && (e.value *= Math.random()) } else e.velocity = 0 } calcPosition(t, e, i, o = 0) { var n, s; for (const [, o] of t.plugins) { const t = void 0 !== o.particlePosition ? o.particlePosition(e, this) : void 0; if (void 0 !== t) return pi.create(t.x, t.y, i) } const a = t.canvas.size, r = pi.create(null !== (n = null == e ? void 0 : e.x) && void 0 !== n ? n : Math.random() * a.width, null !== (s = null == e ? void 0 : e.y) && void 0 !== s ? s : Math.random() * a.height, i), l = this.options.move.outMode; return (Z(l, g.bounce) || Z(l, g.bounceHorizontal)) && (r.x > t.canvas.size.width - 2 * this.size.value ? r.x -= this.size.value : r.x < 2 * this.size.value && (r.x += this.size.value)), (Z(l, g.bounce) || Z(l, g.bounceVertical)) && (r.y > t.canvas.size.height - 2 * this.size.value ? r.y -= this.size.value : r.y < 2 * this.size.value && (r.y += this.size.value)), this.checkOverlap(r, o) ? this.calcPosition(t, void 0, i, o + 1) : r } checkOverlap(t, e = 0) { const i = this.options.collisions.overlap; if (!i.enable) { const o = i.retries; if (o >= 0 && e > o) throw new Error("Particle is overlapping and can't be placed"); let n = !1; for (const e of this.container.particles.array) if (H(t, e.position) < this.size.value + e.size.value) { n = !0; break } return n } return !1 } calculateVelocity() { const t = F(this.direction).copy(), e = this.options.move, i = Math.PI / 180 * e.angle.value, o = Math.PI / 180 * e.angle.offset, n = { left: o - i / 2, right: o + i / 2 }; return e.straight || (t.angle += k(z(n.left, n.right))), e.random && "number" == typeof e.speed && (t.length *= Math.random()), t } loadShapeData(t, e) { const i = t.options[this.shape]; if (i) return it({}, i instanceof Array ? Y(i, this.id, e) : i) } loadLife() { const t = this.container, e = this.options, i = e.life, o = { delay: t.retina.reduceFactor ? E(i.delay.value) * (i.delay.sync ? 1 : Math.random()) / t.retina.reduceFactor * 1e3 : 0, delayTime: 0, duration: t.retina.reduceFactor ? E(i.duration.value) * (i.duration.sync ? 1 : Math.random()) / t.retina.reduceFactor * 1e3 : 0, time: 0, count: e.life.count }; return o.duration <= 0 && (o.duration = -1), o.count <= 0 && (o.count = -1), o } } class gi { constructor(t) { this.container = t; const e = he.getInteractors(t); this.externalInteractors = [], this.particleInteractors = []; for (const t of e) switch (t.type) { case S.External: this.externalInteractors.push(t); break; case S.Particles: this.particleInteractors.push(t) } } externalInteract(t) { for (const e of this.externalInteractors) e.isEnabled() && e.interact(t) } particlesInteract(t, e) { for (const e of this.externalInteractors) e.reset(t); for (const i of this.particleInteractors) i.isEnabled(t) && i.interact(t, e) } } class yi { constructor(t) { this.container = t } move(t, e) { t.destroyed || (this.moveParticle(t, e), this.moveParallax(t)) } moveParticle(t, e) { var i, o, n; const s = t.options, a = s.move; if (!a.enable) return; const r = this.container, l = this.getProximitySpeedFactor(t), c = (null !== (i = t.moveSpeed) && void 0 !== i ? i : t.moveSpeed = E(a.speed) * r.retina.pixelRatio) * r.retina.reduceFactor, h = null !== (o = t.moveDrift) && void 0 !== o ? o : t.moveDrift = E(t.options.move.drift) * r.retina.pixelRatio, d = M(s.size.value) * r.retina.pixelRatio, u = c * ((a.size ? t.getRadius() / d : 1) * l * e.factor / 2); this.applyPath(t, e); const p = a.gravity, v = p.enable && p.inverse ? -1 : 1; p.enable && (t.velocity.y += v * (p.acceleration * e.factor) / (60 * u)), h && u && (t.velocity.x += h * e.factor / (60 * u)); const g = 1 - t.options.move.decay; 1 != g && t.velocity.multTo(g); const y = t.velocity.mult(u), f = null !== (n = t.maxSpeed) && void 0 !== n ? n : r.retina.maxSpeed; p.enable && p.maxSpeed > 0 && (!p.inverse && y.y >= 0 && y.y >= f || p.inverse && y.y <= 0 && y.y <= -f) && (y.y = v * f, u && (t.velocity.y = y.y / u)); const m = 1 - t.options.zIndex.velocityRate * t.zIndexFactor; a.spin.enable ? this.spin(t, u) : (1 != m && y.multTo(m), t.position.addTo(y), a.vibrate && (t.position.x += Math.sin(t.position.x * Math.cos(t.position.y)), t.position.y += Math.cos(t.position.y * Math.sin(t.position.x)))), function (t) { const e = t.initialPosition, { dx: i, dy: o } = I(e, t.position), n = Math.abs(i), s = Math.abs(o), a = t.maxDistance.horizontal, r = t.maxDistance.vertical; if (a || r) if ((a && n >= a || r && s >= r) && !t.misplaced) t.misplaced = !!a && n > a || !!r && s > r, a && (t.velocity.x = t.velocity.y / 2 - t.velocity.x), r && (t.velocity.y = t.velocity.x / 2 - t.velocity.y); else if ((!a || n < a) && (!r || s < r) && t.misplaced) t.misplaced = !1; else if (t.misplaced) { const i = t.position, o = t.velocity; a && (i.x < e.x && o.x < 0 || i.x > e.x && o.x > 0) && (o.x *= -Math.random()), r && (i.y < e.y && o.y < 0 || i.y > e.y && o.y > 0) && (o.y *= -Math.random()) } }(t) } spin(t, e) { const i = this.container; if (!t.spin) return; const o = { x: t.spin.direction === r.clockwise ? Math.cos : Math.sin, y: t.spin.direction === r.clockwise ? Math.sin : Math.cos }; t.position.x = t.spin.center.x + t.spin.radius * o.x(t.spin.angle), t.position.y = t.spin.center.y + t.spin.radius * o.y(t.spin.angle), t.spin.radius += t.spin.acceleration; const n = Math.min(i.canvas.size.width, i.canvas.size.height); t.spin.radius > n / 2 ? (t.spin.radius = n / 2, t.spin.acceleration *= -1) : t.spin.radius < 0 && (t.spin.radius = 0, t.spin.acceleration *= -1), t.spin.angle += e / 100 * (1 - t.spin.radius / n) } applyPath(t, e) { const i = t.options.move.path; if (!i.enable) return; const o = this.container; if (t.lastPathTime <= t.pathDelay) return void (t.lastPathTime += e.value); let n = o.pathGenerator; if (i.generator) { const t = he.getPathGenerator(i.generator); t && (n = t) } const s = n.generate(t); t.velocity.addTo(s), i.clamp && (t.velocity.x = O(t.velocity.x, -1, 1), t.velocity.y = O(t.velocity.y, -1, 1)), t.lastPathTime -= t.pathDelay } moveParallax(t) { const e = this.container, i = e.actualOptions; if (Q() || !i.interactivity.events.onHover.parallax.enable) return; const o = i.interactivity.events.onHover.parallax.force, n = e.interactivity.mouse.position; if (!n) return; const s = e.canvas.size.width / 2, a = e.canvas.size.height / 2, r = i.interactivity.events.onHover.parallax.smooth, l = t.getRadius() / o, c = (n.x - s) * l, h = (n.y - a) * l; t.offset.x += (c - t.offset.x) / r, t.offset.y += (h - t.offset.y) / r } getProximitySpeedFactor(t) { const e = this.container, i = e.actualOptions; if (!Z(p.slow, i.interactivity.events.onHover.mode)) return 1; const o = this.container.interactivity.mouse.position; if (!o) return 1; const n = H(o, t.getPosition()), s = e.retina.slowModeRadius; if (n > s) return 1; return (n / s || 0) / i.interactivity.modes.slow.factor } } class fi { constructor(t) { this.container = t, this.nextId = 0, this.array = [], this.zArray = [], this.mover = new yi(t), this.limit = 0, this.needsSort = !1, this.lastZIndex = 0, this.linksFreq = new Map, this.trianglesFreq = new Map, this.interactionManager = new gi(t); const e = this.container.canvas.size; this.linksColors = new Map, this.quadTree = new ue(new Yt(-e.width / 4, -e.height / 4, 3 * e.width / 2, 3 * e.height / 2), 4), this.updaters = he.getUpdaters(t) } get count() { return this.array.length } init() { var t; const e = this.container, i = e.actualOptions; this.lastZIndex = 0, this.needsSort = !1, this.linksFreq = new Map, this.trianglesFreq = new Map; let o = !1; for (const [, t] of e.plugins) if (void 0 !== t.particlesInitialization && (o = t.particlesInitialization()), o) break; if (this.addManualParticles(), !o) { for (const e in i.particles.groups) { const o = i.particles.groups[e]; for (let n = this.count, s = 0; s < (null === (t = o.number) || void 0 === t ? void 0 : t.value) && n < i.particles.number.value; n++, s++)this.addParticle(void 0, o, e) } for (let t = this.count; t < i.particles.number.value; t++)this.addParticle() } e.pathGenerator.init() } redraw() { this.clear(), this.init(), this.draw({ value: 0, factor: 0 }) } removeAt(t, e = 1, i, o) { if (!(t >= 0 && t <= this.count)) return; let n = 0; for (let s = t; n < e && s < this.count; s++) { const t = this.array[s]; if (!t || t.group !== i) continue; t.destroy(o), this.array.splice(s--, 1); const e = this.zArray.indexOf(t); this.zArray.splice(e, 1), n++ } } remove(t, e, i) { this.removeAt(this.array.indexOf(t), void 0, e, i) } update(t) { const e = this.container, i = []; e.pathGenerator.update(); for (const [, i] of e.plugins) void 0 !== i.update && i.update(t); for (const o of this.array) { const n = e.canvas.resizeFactor; n && (o.position.x *= n.width, o.position.y *= n.height), o.bubble.inRange = !1; for (const [, e] of this.container.plugins) { if (o.destroyed) break; e.particleUpdate && e.particleUpdate(o, t) } this.mover.move(o, t), o.destroyed ? i.push(o) : this.quadTree.insert(new de(o.getPosition(), o)) } for (const t of i) this.remove(t); this.interactionManager.externalInteract(t); for (const i of e.particles.array) { for (const e of this.updaters) e.update(i, t); i.destroyed || i.spawning || this.interactionManager.particlesInteract(i, t) } delete e.canvas.resizeFactor } draw(t) { const e = this.container; e.canvas.clear(); const i = this.container.canvas.size; this.quadTree = new ue(new Yt(-i.width / 4, -i.height / 4, 3 * i.width / 2, 3 * i.height / 2), 4), this.update(t), this.needsSort && (this.zArray.sort(((t, e) => e.position.z - t.position.z || t.id - e.id)), this.lastZIndex = this.zArray[this.zArray.length - 1].position.z, this.needsSort = !1); for (const [, i] of e.plugins) e.canvas.drawPlugin(i, t); for (const e of this.zArray) e.draw(t) } clear() { this.array = [], this.zArray = [] } push(t, e, i, o) { this.pushing = !0; for (let n = 0; n < t; n++)this.addParticle(null == e ? void 0 : e.position, i, o); this.pushing = !1 } addParticle(t, e, i) { const o = this.container, n = o.actualOptions.particles.number.limit * o.density; if (n > 0) { const t = this.count + 1 - n; t > 0 && this.removeQuantity(t) } return this.pushParticle(t, e, i) } addSplitParticle(t) { const e = t.options.destroy.split, i = new ui; i.load(t.options); const o = E(e.factor.value); i.color.load({ value: { hsl: t.getFillColor() } }), "number" == typeof i.size.value ? i.size.value /= o : (i.size.value.min /= o, i.size.value.max /= o), i.load(e.particles); const n = e.sizeOffset ? z(-t.size.value, t.size.value) : 0, s = { x: t.position.x + k(n), y: t.position.y + k(n) }; return this.pushParticle(s, i, t.group, (e => !(e.size.value < .5) && (e.velocity.length = k(z(t.velocity.length, e.velocity.length)), e.splitCount = t.splitCount + 1, e.unbreakable = !0, setTimeout((() => { e.unbreakable = !1 }), 500), !0))) } removeQuantity(t, e) { this.removeAt(0, t, e) } getLinkFrequency(t, e) { const i = `${Math.min(t.id, e.id)}_${Math.max(t.id, e.id)}`; let o = this.linksFreq.get(i); return void 0 === o && (o = Math.random(), this.linksFreq.set(i, o)), o } getTriangleFrequency(t, e, i) { let [o, n, s] = [t.id, e.id, i.id]; o > n && ([n, o] = [o, n]), n > s && ([s, n] = [n, s]), o > s && ([s, o] = [o, s]); const a = `${o}_${n}_${s}`; let r = this.trianglesFreq.get(a); return void 0 === r && (r = Math.random(), this.trianglesFreq.set(a, r)), r } addManualParticles() { const t = this.container, e = t.actualOptions; for (const i of e.manualParticles) { const e = i.position ? { x: i.position.x * t.canvas.size.width / 100, y: i.position.y * t.canvas.size.height / 100 } : void 0; this.addParticle(e, i.options) } } setDensity() { const t = this.container.actualOptions; for (const e in t.particles.groups) this.applyDensity(t.particles.groups[e], 0, e); this.applyDensity(t.particles, t.manualParticles.length) } applyDensity(t, e, i) { var o; if (!(null === (o = t.number.density) || void 0 === o ? void 0 : o.enable)) return; const n = t.number, s = this.initDensityFactor(n.density), a = n.value, r = n.limit > 0 ? n.limit : a, l = Math.min(a, r) * s + e, c = Math.min(this.count, this.array.filter((t => t.group === i)).length); this.limit = n.limit * s, c < l ? this.push(Math.abs(l - c), void 0, t, i) : c > l && this.removeQuantity(c - l, i) } initDensityFactor(t) { const e = this.container; if (!e.canvas.element || !t.enable) return 1; const i = e.canvas.element, o = e.retina.pixelRatio; return i.width * i.height / (t.factor * Math.pow(o, 2) * t.area) } pushParticle(t, e, i, o) { try { const n = new vi(this.nextId, this.container, t, e, i); let s = !0; if (o && (s = o(n)), !s) return; return this.array.push(n), this.zArray.push(n), this.nextId++, n } catch (t) { return void console.warn(`error adding particle: ${t}`) } } } class mi { constructor(t) { this.container = t } init() { const t = this.container, e = t.actualOptions; this.pixelRatio = !e.detectRetina || Q() ? 1 : window.devicePixelRatio; const i = this.container.actualOptions.motion; if (i && (i.disable || i.reduce.value)) if (Q() || "undefined" == typeof matchMedia || !matchMedia) this.reduceFactor = 1; else { const e = matchMedia("(prefers-reduced-motion: reduce)"); if (e) { this.handleMotionChange(e); const i = () => { this.handleMotionChange(e), t.refresh().catch((() => { })) }; void 0 !== e.addEventListener ? e.addEventListener("change", i) : void 0 !== e.addListener && e.addListener(i) } } else this.reduceFactor = 1; const o = this.pixelRatio; if (t.canvas.element) { const e = t.canvas.element; t.canvas.size.width = e.offsetWidth * o, t.canvas.size.height = e.offsetHeight * o } const n = e.particles; this.attractDistance = n.move.attract.distance * o, this.linksDistance = n.links.distance * o, this.linksWidth = n.links.width * o, this.sizeAnimationSpeed = n.size.animation.speed * o, this.maxSpeed = n.move.gravity.maxSpeed * o, void 0 !== n.orbit.radius && (this.orbitRadius = n.orbit.radius * this.container.retina.pixelRatio); const s = e.interactivity.modes; this.connectModeDistance = s.connect.distance * o, this.connectModeRadius = s.connect.radius * o, this.grabModeDistance = s.grab.distance * o, this.repulseModeDistance = s.repulse.distance * o, this.bounceModeDistance = s.bounce.distance * o, this.attractModeDistance = s.attract.distance * o, this.slowModeRadius = s.slow.radius * o, this.bubbleModeDistance = s.bubble.distance * o, s.bubble.size && (this.bubbleModeSize = s.bubble.size * o) } initParticle(t) { const e = t.options, i = this.pixelRatio, o = e.move.distance, n = e.orbit; t.attractDistance = e.move.attract.distance * i, t.linksDistance = e.links.distance * i, t.linksWidth = e.links.width * i, t.moveDrift = E(e.move.drift) * i, t.moveSpeed = E(e.move.speed) * i, t.sizeAnimationSpeed = e.size.animation.speed * i, t.orbitRadius = void 0 !== (null == n ? void 0 : n.radius) ? n.radius * i : void 0, t.spin && (t.spin.acceleration = E(e.move.spin.acceleration) * i); const s = t.maxDistance; s.horizontal = void 0 !== o.horizontal ? o.horizontal * i : void 0, s.vertical = void 0 !== o.vertical ? o.vertical * i : void 0, t.wobbleDistance = E(e.wobble.distance) * i, t.maxSpeed = e.move.gravity.maxSpeed * i } handleMotionChange(t) { const e = this.container.actualOptions; if (t.matches) { const t = e.motion; this.reduceFactor = t.disable ? 0 : t.reduce.value ? 1 / t.reduce.factor : 1 } else this.reduceFactor = 1 } } class wi { constructor(t) { this.container = t } nextFrame(t) { var e; try { const i = this.container; if (void 0 !== i.lastFrameTime && t < i.lastFrameTime + 1e3 / i.fpsLimit) return void i.draw(!1); null !== (e = i.lastFrameTime) && void 0 !== e || (i.lastFrameTime = t); const o = t - i.lastFrameTime, n = { value: o, factor: 60 * o / 1e3 }; if (i.lifeTime += n.value, i.lastFrameTime = t, o > 1e3) return void i.draw(!1); if (i.particles.draw(n), i.duration > 0 && i.lifeTime > i.duration) return void i.destroy(); i.getAnimationStatus() && i.draw(!1) } catch (t) { console.error("tsParticles error in animation loop", t) } } } class bi { constructor() { this.enable = !1, this.mode = [] } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode)) } } class Si { constructor() { this.selectors = [], this.enable = !1, this.mode = [], this.type = x.circle } get elementId() { return this.ids } set elementId(t) { this.ids = t } get el() { return this.elementId } set el(t) { this.elementId = t } get ids() { return this.selectors instanceof Array ? this.selectors.map((t => t.replace("#", ""))) : this.selectors.replace("#", "") } set ids(t) { this.selectors = t instanceof Array ? t.map((t => `#${t}`)) : `#${t}` } load(t) { var e, i; if (void 0 === t) return; const o = null !== (i = null !== (e = t.ids) && void 0 !== e ? e : t.elementId) && void 0 !== i ? i : t.el; void 0 !== o && (this.ids = o), void 0 !== t.selectors && (this.selectors = t.selectors), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.type && (this.type = t.type) } } class Pi { constructor() { this.enable = !1, this.force = 2, this.smooth = 10 } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.force && (this.force = t.force), void 0 !== t.smooth && (this.smooth = t.smooth)) } } class _i { constructor() { this.enable = !1, this.mode = [], this.parallax = new Pi } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode), this.parallax.load(t.parallax)) } } class xi { constructor() { this.onClick = new bi, this.onDiv = new Si, this.onHover = new _i, this.resize = !0 } get onclick() { return this.onClick } set onclick(t) { this.onClick = t } get ondiv() { return this.onDiv } set ondiv(t) { this.onDiv = t } get onhover() { return this.onHover } set onhover(t) { this.onHover = t } load(t) { var e, i, o; if (void 0 === t) return; this.onClick.load(null !== (e = t.onClick) && void 0 !== e ? e : t.onclick); const n = null !== (i = t.onDiv) && void 0 !== i ? i : t.ondiv; void 0 !== n && (n instanceof Array ? this.onDiv = n.map((t => { const e = new Si; return e.load(t), e })) : (this.onDiv = new Si, this.onDiv.load(n))), this.onHover.load(null !== (o = t.onHover) && void 0 !== o ? o : t.onhover), void 0 !== t.resize && (this.resize = t.resize) } } class Ci { constructor() { this.distance = 200, this.duration = .4, this.mix = !1 } load(t) { void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.mix && (this.mix = t.mix), void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.color && (t.color instanceof Array ? this.color = t.color.map((t => ve.create(void 0, t))) : (this.color instanceof Array && (this.color = new ve), this.color = ve.create(this.color, t.color))), void 0 !== t.size && (this.size = t.size)) } } class Ai extends Ci { constructor() { super(), this.selectors = [] } get ids() { return this.selectors instanceof Array ? this.selectors.map((t => t.replace("#", ""))) : this.selectors.replace("#", "") } set ids(t) { this.selectors = t instanceof Array ? t.map((t => `#${t}`)) : `#${t}` } load(t) { super.load(t), void 0 !== t && (void 0 !== t.ids && (this.ids = t.ids), void 0 !== t.selectors && (this.selectors = t.selectors)) } } class Vi extends Ci { load(t) { super.load(t), void 0 !== t && void 0 !== t.divs && (t.divs instanceof Array ? this.divs = t.divs.map((t => { const e = new Ai; return e.load(t), e })) : ((this.divs instanceof Array || !this.divs) && (this.divs = new Ai), this.divs.load(t.divs))) } } class Gi { constructor() { this.opacity = .5 } load(t) { void 0 !== t && void 0 !== t.opacity && (this.opacity = t.opacity) } } class Oi { constructor() { this.distance = 80, this.links = new Gi, this.radius = 60 } get line_linked() { return this.links } set line_linked(t) { this.links = t } get lineLinked() { return this.links } set lineLinked(t) { this.links = t } load(t) { var e, i; void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), this.links.load(null !== (i = null !== (e = t.links) && void 0 !== e ? e : t.lineLinked) && void 0 !== i ? i : t.line_linked), void 0 !== t.radius && (this.radius = t.radius)) } } class Ti { constructor() { this.blink = !1, this.consent = !1, this.opacity = 1 } load(t) { void 0 !== t && (void 0 !== t.blink && (this.blink = t.blink), void 0 !== t.color && (this.color = ve.create(this.color, t.color)), void 0 !== t.consent && (this.consent = t.consent), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class ki { constructor() { this.distance = 100, this.links = new Ti } get line_linked() { return this.links } set line_linked(t) { this.links = t } get lineLinked() { return this.links } set lineLinked(t) { this.links = t } load(t) { var e, i; void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), this.links.load(null !== (i = null !== (e = t.links) && void 0 !== e ? e : t.lineLinked) && void 0 !== i ? i : t.line_linked)) } } class Ei { constructor() { this.quantity = 2 } get particles_nb() { return this.quantity } set particles_nb(t) { this.quantity = t } load(t) { var e; if (void 0 === t) return; const i = null !== (e = t.quantity) && void 0 !== e ? e : t.particles_nb; void 0 !== i && (this.quantity = i) } } class Ri { constructor() { this.default = !0, this.groups = [], this.quantity = 4 } get particles_nb() { return this.quantity } set particles_nb(t) { this.quantity = t } load(t) { var e; if (void 0 === t) return; void 0 !== t.default && (this.default = t.default), void 0 !== t.groups && (this.groups = t.groups.map((t => t))), this.groups.length || (this.default = !0); const i = null !== (e = t.quantity) && void 0 !== e ? e : t.particles_nb; void 0 !== i && (this.quantity = i) } } class Mi { constructor() { this.distance = 200, this.duration = .4, this.factor = 100, this.speed = 1, this.maxSpeed = 50, this.easing = C.easeOutQuad } load(t) { t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.easing && (this.easing = t.easing), void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.maxSpeed && (this.maxSpeed = t.maxSpeed)) } } class zi extends Mi { constructor() { super(), this.selectors = [] } get ids() { return this.selectors instanceof Array ? this.selectors.map((t => t.replace("#", ""))) : this.selectors.replace("#", "") } set ids(t) { this.selectors = t instanceof Array ? t.map((() => `#${t}`)) : `#${t}` } load(t) { super.load(t), void 0 !== t && (void 0 !== t.ids && (this.ids = t.ids), void 0 !== t.selectors && (this.selectors = t.selectors)) } } class Li extends Mi { load(t) { super.load(t), void 0 !== (null == t ? void 0 : t.divs) && (t.divs instanceof Array ? this.divs = t.divs.map((t => { const e = new zi; return e.load(t), e })) : ((this.divs instanceof Array || !this.divs) && (this.divs = new zi), this.divs.load(t.divs))) } } class Ii { constructor() { this.factor = 3, this.radius = 200 } get active() { return !1 } set active(t) { } load(t) { void 0 !== t && (void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.radius && (this.radius = t.radius)) } } class Hi { constructor() { this.delay = 1, this.pauseOnStop = !1, this.quantity = 1 } load(t) { void 0 !== t && (void 0 !== t.delay && (this.delay = t.delay), void 0 !== t.quantity && (this.quantity = t.quantity), void 0 !== t.particles && (this.particles = it({}, t.particles)), void 0 !== t.pauseOnStop && (this.pauseOnStop = t.pauseOnStop)) } } class Di { constructor() { this.distance = 200, this.duration = .4, this.easing = C.easeOutQuad, this.factor = 1, this.maxSpeed = 50, this.speed = 1 } load(t) { t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.easing && (this.easing = t.easing), void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.maxSpeed && (this.maxSpeed = t.maxSpeed), void 0 !== t.speed && (this.speed = t.speed)) } } class Fi { constructor() { this.start = new ve, this.stop = new ve, this.start.value = "#ffffff", this.stop.value = "#000000" } load(t) { void 0 !== t && (this.start = ve.create(this.start, t.start), this.stop = ve.create(this.stop, t.stop)) } } class Ni { constructor() { this.gradient = new Fi, this.radius = 1e3 } load(t) { void 0 !== t && (this.gradient.load(t.gradient), void 0 !== t.radius && (this.radius = t.radius)) } } class Bi { constructor() { this.color = new ve, this.color.value = "#000000", this.length = 2e3 } load(t) { void 0 !== t && (this.color = ve.create(this.color, t.color), void 0 !== t.length && (this.length = t.length)) } } class ji { constructor() { this.area = new Ni, this.shadow = new Bi } load(t) { void 0 !== t && (this.area.load(t.area), this.shadow.load(t.shadow)) } } class qi { constructor() { this.distance = 200 } load(t) { t && void 0 !== t.distance && (this.distance = t.distance) } } class Ui { constructor() { this.attract = new Di, this.bounce = new qi, this.bubble = new Vi, this.connect = new Oi, this.grab = new ki, this.light = new ji, this.push = new Ri, this.remove = new Ei, this.repulse = new Li, this.slow = new Ii, this.trail = new Hi } load(t) { void 0 !== t && (this.attract.load(t.attract), this.bubble.load(t.bubble), this.connect.load(t.connect), this.grab.load(t.grab), this.light.load(t.light), this.push.load(t.push), this.remove.load(t.remove), this.repulse.load(t.repulse), this.slow.load(t.slow), this.trail.load(t.trail)) } } class Qi { constructor() { this.detectsOn = V.canvas, this.events = new xi, this.modes = new Ui } get detect_on() { return this.detectsOn } set detect_on(t) { this.detectsOn = t } load(t) { var e, i, o; if (void 0 === t) return; const n = null !== (e = t.detectsOn) && void 0 !== e ? e : t.detect_on; void 0 !== n && (this.detectsOn = n), this.events.load(t.events), this.modes.load(t.modes), !0 === (null === (o = null === (i = t.modes) || void 0 === i ? void 0 : i.slow) || void 0 === o ? void 0 : o.active) && (this.events.onHover.mode instanceof Array ? this.events.onHover.mode.indexOf(p.slow) < 0 && this.events.onHover.mode.push(p.slow) : this.events.onHover.mode !== p.slow && (this.events.onHover.mode = [this.events.onHover.mode, p.slow])) } } class Wi { constructor() { this.color = new ve, this.opacity = 1 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = ve.create(this.color, t.color)), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class $i { constructor() { this.composite = "destination-out", this.cover = new Wi, this.enable = !1 } load(t) { if (void 0 !== t) { if (void 0 !== t.composite && (this.composite = t.composite), void 0 !== t.cover) { const e = t.cover, i = "string" == typeof t.cover ? { color: t.cover } : t.cover; this.cover.load(void 0 !== e.color ? e : { color: i }) } void 0 !== t.enable && (this.enable = t.enable) } } } class Zi { constructor() { this.color = new ve, this.color.value = "", this.image = "", this.position = "", this.repeat = "", this.size = "", this.opacity = 1 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = ve.create(this.color, t.color)), void 0 !== t.image && (this.image = t.image), void 0 !== t.position && (this.position = t.position), void 0 !== t.repeat && (this.repeat = t.repeat), void 0 !== t.size && (this.size = t.size), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class Ji { constructor() { this.mode = f.any, this.value = !1 } load(t) { void 0 !== t && (void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.value && (this.value = t.value)) } } class Xi { constructor() { this.name = "", this.default = new Ji } load(t) { void 0 !== t && (void 0 !== t.name && (this.name = t.name), this.default.load(t.default), void 0 !== t.options && (this.options = it({}, t.options))) } } class Yi { constructor() { this.enable = !1, this.zIndex = -1 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.zIndex && (this.zIndex = t.zIndex)) } } class Ki { constructor() { this.factor = 4, this.value = !0 } load(t) { t && (void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.value && (this.value = t.value)) } } class to { constructor() { this.disable = !1, this.reduce = new Ki } load(t) { t && (void 0 !== t.disable && (this.disable = t.disable), this.reduce.load(t.reduce)) } } class eo { load(t) { var e, i; t && (void 0 !== t.position && (this.position = { x: null !== (e = t.position.x) && void 0 !== e ? e : 50, y: null !== (i = t.position.y) && void 0 !== i ? i : 50 }), void 0 !== t.options && (this.options = it({}, t.options))) } } class io { constructor() { this.maxWidth = 1 / 0, this.options = {} } load(t) { t && (void 0 !== t.maxWidth && (this.maxWidth = t.maxWidth), void 0 !== t.options && (this.options = it({}, t.options))) } } class oo { constructor() { this.autoPlay = !0, this.background = new Zi, this.backgroundMask = new $i, this.fullScreen = new Yi, this.detectRetina = !0, this.duration = 0, this.fpsLimit = 60, this.interactivity = new Qi, this.manualParticles = [], this.motion = new to, this.particles = new ui, this.pauseOnBlur = !0, this.pauseOnOutsideViewport = !0, this.responsive = [], this.themes = [] } get fps_limit() { return this.fpsLimit } set fps_limit(t) { this.fpsLimit = t } get retina_detect() { return this.detectRetina } set retina_detect(t) { this.detectRetina = t } get backgroundMode() { return this.fullScreen } set backgroundMode(t) { this.fullScreen.load(t) } load(t) { var e, i, o; if (void 0 === t) return; if (void 0 !== t.preset) if (t.preset instanceof Array) for (const e of t.preset) this.importPreset(e); else this.importPreset(t.preset); void 0 !== t.autoPlay && (this.autoPlay = t.autoPlay); const n = null !== (e = t.detectRetina) && void 0 !== e ? e : t.retina_detect; void 0 !== n && (this.detectRetina = n), void 0 !== t.duration && (this.duration = t.duration); const s = null !== (i = t.fpsLimit) && void 0 !== i ? i : t.fps_limit; if (void 0 !== s && (this.fpsLimit = s), void 0 !== t.pauseOnBlur && (this.pauseOnBlur = t.pauseOnBlur), void 0 !== t.pauseOnOutsideViewport && (this.pauseOnOutsideViewport = t.pauseOnOutsideViewport), this.background.load(t.background), this.fullScreen.load(null !== (o = t.fullScreen) && void 0 !== o ? o : t.backgroundMode), this.backgroundMask.load(t.backgroundMask), this.interactivity.load(t.interactivity), void 0 !== t.manualParticles && (this.manualParticles = t.manualParticles.map((t => { const e = new eo; return e.load(t), e }))), this.motion.load(t.motion), this.particles.load(t.particles), he.loadOptions(this, t), void 0 !== t.responsive) for (const e of t.responsive) { const t = new io; t.load(e), this.responsive.push(t) } if (this.responsive.sort(((t, e) => t.maxWidth - e.maxWidth)), void 0 !== t.themes) for (const e of t.themes) { const t = new Xi; t.load(e), this.themes.push(t) } } setTheme(t) { if (t) { const e = this.themes.find((e => e.name === t)); e && this.load(e.options) } else { const t = "undefined" != typeof matchMedia && matchMedia("(prefers-color-scheme: dark)").matches; let e = this.themes.find((e => e.default.value && (e.default.mode === f.dark && t || e.default.mode === f.light && !t))); e || (e = this.themes.find((t => t.default.value && t.default.mode === f.any))), e && this.load(e.options) } } importPreset(t) { this.load(he.getPreset(t)) } setResponsive(t, e, i) { var o; this.load(i), this.load(null === (o = this.responsive.find((i => i.maxWidth * e > t))) || void 0 === o ? void 0 : o.options) } } var no = function (t, e, i, o) { return new (i || (i = Promise))((function (n, s) { function a(t) { try { l(o.next(t)) } catch (t) { s(t) } } function r(t) { try { l(o.throw(t)) } catch (t) { s(t) } } function l(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i((function (t) { t(e) }))).then(a, r) } l((o = o.apply(t, e || [])).next()) })) }; class so { constructor(t, e, ...i) { this.id = t, this.zLayers = 1e4, this.fpsLimit = 60, this.duration = 0, this.lifeTime = 0, this.firstStart = !0, this.started = !1, this.destroyed = !1, this.paused = !0, this.lastFrameTime = 0, this.pageHidden = !1, this._sourceOptions = e, this.retina = new mi(this), this.canvas = new pe(this), this.particles = new fi(this), this.drawer = new wi(this), this.pathGenerator = { generate: () => { const t = G.create(0, 0); return t.length = Math.random(), t.angle = Math.random() * Math.PI * 2, t }, init: () => { }, update: () => { } }, this.interactivity = { mouse: { clicking: !1, inside: !1 } }, this.bubble = {}, this.repulse = { particles: [] }, this.attract = { particles: [] }, this.plugins = new Map, this.drawers = new Map, this.density = 1, this._options = new oo, this.actualOptions = new oo; for (const t of i) this._options.load(he.getPreset(t)); const o = he.getSupportedShapes(); for (const t of o) { const e = he.getShapeDrawer(t); e && this.drawers.set(t, e) } this._options && this._options.load(this._sourceOptions), this.eventListeners = new ee(this), "undefined" != typeof IntersectionObserver && IntersectionObserver && (this.intersectionObserver = new IntersectionObserver((t => this.intersectionManager(t)))) } get options() { return this._options } get sourceOptions() { return this._sourceOptions } play(t) { const e = this.paused || t; if (!this.firstStart || this.actualOptions.autoPlay) { if (this.paused && (this.paused = !1), e) for (const [, t] of this.plugins) t.play && t.play(); this.draw(e || !1) } else this.firstStart = !1 } pause() { if (void 0 !== this.drawAnimationFrame && ($()(this.drawAnimationFrame), delete this.drawAnimationFrame), !this.paused) { for (const [, t] of this.plugins) t.pause && t.pause(); this.pageHidden || (this.paused = !0) } } draw(t) { let e = t; this.drawAnimationFrame = W()((t => { e && (this.lastFrameTime = void 0, e = !1), this.drawer.nextFrame(t) })) } getAnimationStatus() { return !this.paused && !this.pageHidden } setNoise(t, e, i) { this.setPath(t, e, i) } setPath(t, e, i) { t && ("function" == typeof t ? (this.pathGenerator.generate = t, e && (this.pathGenerator.init = e), i && (this.pathGenerator.update = i)) : (t.generate && (this.pathGenerator.generate = t.generate), t.init && (this.pathGenerator.init = t.init), t.update && (this.pathGenerator.update = t.update))) } destroy() { this.stop(), this.canvas.destroy(); for (const [, t] of this.drawers) t.destroy && t.destroy(this); for (const t of this.drawers.keys()) this.drawers.delete(t); this.destroyed = !0 } exportImg(t) { this.exportImage(t) } exportImage(t, e, i) { var o; return null === (o = this.canvas.element) || void 0 === o ? void 0 : o.toBlob(t, null != e ? e : "image/png", i) } exportConfiguration() { return JSON.stringify(this.actualOptions, void 0, 2) } refresh() { return this.stop(), this.start() } reset() { return this._options = new oo, this.refresh() } stop() { if (this.started) { this.firstStart = !0, this.started = !1, this.eventListeners.removeListeners(), this.pause(), this.particles.clear(), this.canvas.clear(), this.interactivity.element instanceof HTMLElement && this.intersectionObserver && this.intersectionObserver.observe(this.interactivity.element); for (const [, t] of this.plugins) t.stop && t.stop(); for (const t of this.plugins.keys()) this.plugins.delete(t); this.particles.linksColors = new Map, delete this.particles.grabLineColor, delete this.particles.linksColor } } loadTheme(t) { return no(this, void 0, void 0, (function* () { this.currentTheme = t, yield this.refresh() })) } start() { return no(this, void 0, void 0, (function* () { if (!this.started) { yield this.init(), this.started = !0, this.eventListeners.addListeners(), this.interactivity.element instanceof HTMLElement && this.intersectionObserver && this.intersectionObserver.observe(this.interactivity.element); for (const [, t] of this.plugins) void 0 !== t.startAsync ? yield t.startAsync() : void 0 !== t.start && t.start(); this.play() } })) } addClickHandler(t) { const e = this.interactivity.element; if (!e) return; const i = (e, i) => { if (this.destroyed) return; const o = this.retina.pixelRatio, n = { x: i.x * o, y: i.y * o }, s = this.particles.quadTree.queryCircle(n, this.retina.sizeValue); t(e, s) }; let o = !1, n = !1; e.addEventListener("click", (t => { if (this.destroyed) return; const e = t, o = { x: e.offsetX || e.clientX, y: e.offsetY || e.clientY }; i(t, o) })), e.addEventListener("touchstart", (() => { this.destroyed || (o = !0, n = !1) })), e.addEventListener("touchmove", (() => { this.destroyed || (n = !0) })), e.addEventListener("touchend", (t => { var e, s, a; if (!this.destroyed) { if (o && !n) { const o = t, n = o.touches[o.touches.length - 1], r = null === (e = this.canvas.element) || void 0 === e ? void 0 : e.getBoundingClientRect(), l = { x: n.clientX - (null !== (s = null == r ? void 0 : r.left) && void 0 !== s ? s : 0), y: n.clientY - (null !== (a = null == r ? void 0 : r.top) && void 0 !== a ? a : 0) }; i(t, l) } o = !1, n = !1 } })), e.addEventListener("touchcancel", (() => { this.destroyed || (o = !1, n = !1) })) } init() { return no(this, void 0, void 0, (function* () { this.actualOptions = new oo, this.actualOptions.load(this._options), this.retina.init(), this.canvas.init(), this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, this._options), this.actualOptions.setTheme(this.currentTheme), this.canvas.initBackground(), this.canvas.resize(), this.duration = E(this.actualOptions.duration), this.lifeTime = 0, this.fpsLimit = this.actualOptions.fpsLimit > 0 ? this.actualOptions.fpsLimit : 60; const t = he.getAvailablePlugins(this); for (const [e, i] of t) this.plugins.set(e, i); for (const [, t] of this.drawers) t.init && (yield t.init(this)); for (const [, t] of this.plugins) t.init ? t.init(this.actualOptions) : void 0 !== t.initAsync && (yield t.initAsync(this.actualOptions)); this.particles.init(), this.particles.setDensity(); for (const [, t] of this.plugins) void 0 !== t.particlesSetup && t.particlesSetup() })) } intersectionManager(t) { if (this.actualOptions.pauseOnOutsideViewport) for (const e of t) e.target === this.interactivity.element && (e.isIntersecting ? this.play() : this.pause()) } } var ao = function (t, e, i, o) { return new (i || (i = Promise))((function (n, s) { function a(t) { try { l(o.next(t)) } catch (t) { s(t) } } function r(t) { try { l(o.throw(t)) } catch (t) { s(t) } } function l(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i((function (t) { t(e) }))).then(a, r) } l((o = o.apply(t, e || [])).next()) })) }; const ro = []; function lo(t) { console.error(`Error tsParticles - fetch status: ${t}`), console.error("Error tsParticles - File config not found") } class co { static dom() { return ro } static domItem(t) { const e = co.dom(), i = e[t]; if (i && !i.destroyed) return i; e.splice(t, 1) } static load(t, e, i) { return ao(this, void 0, void 0, (function* () { let o = document.getElementById(t); return o || (o = document.createElement("div"), o.id = t, document.append(o)), co.set(t, o, e, i) })) } static set(t, e, i, o) { return ao(this, void 0, void 0, (function* () { const n = i instanceof Array ? Y(i, o) : i, s = co.dom(), a = s.findIndex((e => e.id === t)); if (a >= 0) { const t = co.domItem(a); t && !t.destroyed && (t.destroy(), s.splice(a, 1)) } let r, l; if ("canvas" === e.tagName.toLowerCase()) r = e, l = !1; else { const t = e.getElementsByTagName("canvas"); t.length ? (r = t[0], r.className || (r.className = ht.canvasClass), l = !1) : (l = !0, r = document.createElement("canvas"), r.className = ht.canvasClass, r.style.width = "100%", r.style.height = "100%", e.appendChild(r)) } const c = new so(t, n); return a >= 0 ? s.splice(a, 0, c) : s.push(c), c.canvas.loadCanvas(r, l), yield c.start(), c })) } static loadJSON(t, e, i) { return ao(this, void 0, void 0, (function* () { const o = e instanceof Array ? Y(e, i) : e, n = yield fetch(o); if (n.ok) return co.load(t, yield n.json()); lo(n.status) })) } static setJSON(t, e, i, o) { return ao(this, void 0, void 0, (function* () { const n = i instanceof Array ? Y(i, o) : i, s = yield fetch(n); if (s.ok) { const i = yield s.json(); return co.set(t, e, i) } lo(s.status) })) } static setOnClickHandler(t) { const e = co.dom(); if (0 === e.length) throw new Error("Can only set click handlers after calling tsParticles.load() or tsParticles.loadJSON()"); for (const i of e) i.addClickHandler(t) } } var ho, uo, po, vo, go, yo, fo = function (t, e, i, o) { return new (i || (i = Promise))((function (n, s) { function a(t) { try { l(o.next(t)) } catch (t) { s(t) } } function r(t) { try { l(o.throw(t)) } catch (t) { s(t) } } function l(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i((function (t) { t(e) }))).then(a, r) } l((o = o.apply(t, e || [])).next()) })) }, mo = function (t, e, i, o, n) { if ("m" === o) throw new TypeError("Private method is not writable"); if ("a" === o && !n) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === o ? n.call(t, i) : n ? n.value = i : e.set(t, i), i }, wo = function (t, e, i, o) { if ("a" === i && !o) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !o : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === i ? o : "a" === i ? o.call(t) : o ? o.value : e.get(t) }; class bo { constructor() { ho.set(this, void 0), mo(this, ho, !1, "f") } init() { wo(this, ho, "f") || mo(this, ho, !0, "f") } loadFromArray(t, e, i) { return fo(this, void 0, void 0, (function* () { return co.load(t, e, i) })) } load(t, e) { return fo(this, void 0, void 0, (function* () { return co.load(t, e) })) } set(t, e, i) { return fo(this, void 0, void 0, (function* () { return co.set(t, e, i) })) } loadJSON(t, e, i) { return co.loadJSON(t, e, i) } setJSON(t, e, i, o) { return fo(this, void 0, void 0, (function* () { return co.setJSON(t, e, i, o) })) } setOnClickHandler(t) { co.setOnClickHandler(t) } dom() { return co.dom() } domItem(t) { return co.domItem(t) } addShape(t, e, i, o, n) { let s; s = "function" == typeof e ? { afterEffect: o, destroy: n, draw: e, init: i } : e, he.addShapeDrawer(t, s) } addPreset(t, e, i = !1) { he.addPreset(t, e, i) } addPlugin(t) { he.addPlugin(t) } addPathGenerator(t, e) { he.addPathGenerator(t, e) } addInteractor(t, e) { he.addInteractor(t, e) } addParticleUpdater(t, e) { he.addParticleUpdater(t, e) } } ho = new WeakMap; class So { constructor(t, e, i, o) { var n, s, a; this.absorbers = t, this.container = e, this.initialPosition = o ? G.create(o.x, o.y) : void 0, this.options = i, this.dragging = !1, this.name = this.options.name, this.opacity = this.options.opacity, this.size = E(i.size.value) * e.retina.pixelRatio, this.mass = this.size * i.size.density * e.retina.reduceFactor; const r = i.size.limit; this.limit = void 0 !== r ? r * e.retina.pixelRatio * e.retina.reduceFactor : r; const l = "string" == typeof i.color ? { value: i.color } : i.color; this.color = null !== (n = pt(l)) && void 0 !== n ? n : { b: 0, g: 0, r: 0 }, this.position = null !== (a = null === (s = this.initialPosition) || void 0 === s ? void 0 : s.copy()) && void 0 !== a ? a : this.calcPosition() } attract(t) { const e = this.container, i = this.options; if (i.draggable) { const t = e.interactivity.mouse; if (t.clicking && t.downPosition) { H(this.position, t.downPosition) <= this.size && (this.dragging = !0) } else this.dragging = !1; this.dragging && t.position && (this.position.x = t.position.x, this.position.y = t.position.y) } const o = t.getPosition(), { dx: n, dy: s, distance: a } = I(this.position, o), r = G.create(n, s); if (r.length = this.mass / Math.pow(a, 2) * e.retina.reduceFactor, a < this.size + t.getRadius()) { const o = .033 * t.getRadius() * e.retina.pixelRatio; this.size > t.getRadius() && a < this.size - t.getRadius() || void 0 !== t.absorberOrbit && t.absorberOrbit.length < 0 ? i.destroy ? t.destroy() : (t.needsNewPosition = !0, this.updateParticlePosition(t, r)) : (i.destroy && (t.size.value -= o), this.updateParticlePosition(t, r)), (void 0 === this.limit || this.size < this.limit) && (this.size += o), this.mass += o * this.options.size.density * e.retina.reduceFactor } else this.updateParticlePosition(t, r) } resize() { const t = this.initialPosition; this.position = t && K(t, this.container.canvas.size) ? t : this.calcPosition() } draw(t) { t.translate(this.position.x, this.position.y), t.beginPath(), t.arc(0, 0, this.size, 0, 2 * Math.PI, !1), t.closePath(), t.fillStyle = Ot(this.color, this.opacity), t.fill() } calcPosition() { var t, e; const i = this.container, o = this.options.position; return G.create((null !== (t = null == o ? void 0 : o.x) && void 0 !== t ? t : 100 * Math.random()) / 100 * i.canvas.size.width, (null !== (e = null == o ? void 0 : o.y) && void 0 !== e ? e : 100 * Math.random()) / 100 * i.canvas.size.height) } updateParticlePosition(t, e) { var i; if (t.destroyed) return; const o = this.container, n = o.canvas.size; if (t.needsNewPosition) { const e = t.getRadius(); t.position.x = (n.width - 2 * e) * (.2 * Math.random() - .1 + 1) + e, t.position.y = (n.height - 2 * e) * (.2 * Math.random() - .1 + 1) + e, t.needsNewPosition = !1 } if (this.options.orbits) { if (void 0 === t.absorberOrbit && (t.absorberOrbit = G.create(0, 0), t.absorberOrbit.length = H(t.getPosition(), this.position), t.absorberOrbit.angle = Math.random() * Math.PI * 2), t.absorberOrbit.length <= this.size && !this.options.destroy) { const e = Math.min(n.width, n.height); t.absorberOrbit.length = e * (.2 * Math.random() - .1 + 1) } void 0 === t.absorberOrbitDirection && (t.absorberOrbitDirection = t.velocity.x >= 0 ? r.clockwise : r.counterClockwise); const s = t.absorberOrbit.length, a = t.absorberOrbit.angle, l = t.absorberOrbitDirection; t.velocity.x = 0, t.velocity.y = 0; const c = { x: l === r.clockwise ? Math.cos : Math.sin, y: l === r.clockwise ? Math.sin : Math.cos }; t.position.x = this.position.x + s * c.x(a), t.position.y = this.position.y + s * c.y(a), t.absorberOrbit.length -= e.length, t.absorberOrbit.angle += (null !== (i = t.moveSpeed) && void 0 !== i ? i : 0) * o.retina.pixelRatio / 100 * o.retina.reduceFactor } else { const i = G.origin; i.length = e.length, i.angle = e.angle, t.velocity.addTo(i) } } } class Po extends Se { constructor() { super(), this.density = 5, this.random.minimumValue = 1, this.value = 50 } load(t) { t && (super.load(t), void 0 !== t.density && (this.density = t.density), void 0 !== t.limit && (this.limit = t.limit), void 0 !== t.limit && (this.limit = t.limit)) } } class _o { constructor() { this.color = new ve, this.color.value = "#000000", this.draggable = !1, this.opacity = 1, this.destroy = !0, this.orbits = !1, this.size = new Po } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = ve.create(this.color, t.color)), void 0 !== t.draggable && (this.draggable = t.draggable), this.name = t.name, void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.position && (this.position = { x: t.position.x, y: t.position.y }), void 0 !== t.size && this.size.load(t.size), void 0 !== t.destroy && (this.destroy = t.destroy), void 0 !== t.orbits && (this.orbits = t.orbits)) } } !function (t) { t.absorber = "absorber" }(uo || (uo = {})); class xo { constructor(t) { this.container = t, this.array = [], this.absorbers = [], this.interactivityAbsorbers = []; const e = t; e.getAbsorber = t => void 0 === t || "number" == typeof t ? this.array[t || 0] : this.array.find((e => e.name === t)), e.addAbsorber = (t, e) => this.addAbsorber(t, e) } init(t) { var e, i; if (!t) return; t.absorbers && (t.absorbers instanceof Array ? this.absorbers = t.absorbers.map((t => { const e = new _o; return e.load(t), e })) : (this.absorbers instanceof Array && (this.absorbers = new _o), this.absorbers.load(t.absorbers))); const o = null === (i = null === (e = t.interactivity) || void 0 === e ? void 0 : e.modes) || void 0 === i ? void 0 : i.absorbers; if (o && (o instanceof Array ? this.interactivityAbsorbers = o.map((t => { const e = new _o; return e.load(t), e })) : (this.interactivityAbsorbers instanceof Array && (this.interactivityAbsorbers = new _o), this.interactivityAbsorbers.load(o))), this.absorbers instanceof Array) for (const t of this.absorbers) this.addAbsorber(t); else this.addAbsorber(this.absorbers) } particleUpdate(t) { for (const e of this.array) if (e.attract(t), t.destroyed) break } draw(t) { for (const e of this.array) t.save(), e.draw(t), t.restore() } stop() { this.array = [] } resize() { for (const t of this.array) t.resize() } handleClickMode(t) { const e = this.container, i = this.absorbers, o = this.interactivityAbsorbers; if (t === uo.absorber) { let t; o instanceof Array ? o.length > 0 && (t = Y(o)) : t = o; const n = null != t ? t : i instanceof Array ? Y(i) : i, s = e.interactivity.mouse.clickPosition; this.addAbsorber(n, s) } } addAbsorber(t, e) { const i = new So(this, this.container, t, e); return this.array.push(i), i } removeAbsorber(t) { const e = this.array.indexOf(t); e >= 0 && this.array.splice(e, 1) } } class Co { constructor() { this.id = "absorbers" } getPlugin(t) { return new xo(t) } needsPlugin(t) { var e, i, o; if (void 0 === t) return !1; const n = t.absorbers; let s = !1; return n instanceof Array ? n.length && (s = !0) : (void 0 !== n || (null === (o = null === (i = null === (e = t.interactivity) || void 0 === e ? void 0 : e.events) || void 0 === i ? void 0 : i.onClick) || void 0 === o ? void 0 : o.mode) && Z(uo.absorber, t.interactivity.events.onClick.mode)) && (s = !0), s } loadOptions(t, e) { var i, o; if (!this.needsPlugin(t) && !this.needsPlugin(e)) return; const n = t; if (null == e ? void 0 : e.absorbers) if ((null == e ? void 0 : e.absorbers) instanceof Array) n.absorbers = null == e ? void 0 : e.absorbers.map((t => { const e = new _o; return e.load(t), e })); else { let t = n.absorbers; void 0 === (null == t ? void 0 : t.load) && (n.absorbers = t = new _o), t.load(null == e ? void 0 : e.absorbers) } const s = null === (o = null === (i = null == e ? void 0 : e.interactivity) || void 0 === i ? void 0 : i.modes) || void 0 === o ? void 0 : o.absorbers; if (s) if (s instanceof Array) n.interactivity.modes.absorbers = s.map((t => { const e = new _o; return e.load(t), e })); else { let t = n.interactivity.modes.absorbers; void 0 === (null == t ? void 0 : t.load) && (n.interactivity.modes.absorbers = t = new _o), t.load(s) } } } class Ao { constructor() { this.mode = y.percent, this.height = 0, this.width = 0 } load(t) { void 0 !== t && (void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.height && (this.height = t.height), void 0 !== t.width && (this.width = t.width)) } } function Vo(t, e) { return t + e * (Math.random() - .5) } function Go(t, e) { return { x: Vo(t.x, e.x), y: Vo(t.y, e.y) } } class Oo { constructor(t, e, i, o) { var n, s, a, r, l, c, h; this.emitters = t, this.container = e, this.firstSpawn = !0, this.currentDuration = 0, this.currentEmitDelay = 0, this.currentSpawnDelay = 0, this.initialPosition = o, this.emitterOptions = it({}, i), this.spawnDelay = 1e3 * (null !== (n = this.emitterOptions.life.delay) && void 0 !== n ? n : 0) / this.container.retina.reduceFactor, this.position = null !== (s = this.initialPosition) && void 0 !== s ? s : this.calcPosition(), this.name = i.name; let d = it({}, this.emitterOptions.particles); null != d || (d = {}), null !== (a = d.move) && void 0 !== a || (d.move = {}), null !== (r = (h = d.move).direction) && void 0 !== r || (h.direction = this.emitterOptions.direction), void 0 !== this.emitterOptions.spawnColor && (this.spawnColor = vt(this.emitterOptions.spawnColor)), this.paused = !this.emitterOptions.autoPlay, this.particlesOptions = d, this.size = null !== (l = this.emitterOptions.size) && void 0 !== l ? l : (() => { const t = new Ao; return t.load({ height: 0, mode: y.percent, width: 0 }), t })(), this.lifeCount = null !== (c = this.emitterOptions.life.count) && void 0 !== c ? c : -1, this.immortal = this.lifeCount <= 0, this.play() } externalPlay() { this.paused = !1, this.play() } externalPause() { this.paused = !0, this.pause() } play() { if (!this.paused && this.container.retina.reduceFactor && (this.lifeCount > 0 || this.immortal || !this.emitterOptions.life.count)) { if (void 0 === this.emitDelay) { const t = E(this.emitterOptions.rate.delay); this.emitDelay = 1e3 * t / this.container.retina.reduceFactor } (this.lifeCount > 0 || this.immortal) && this.prepareToDie() } } pause() { this.paused || delete this.emitDelay } resize() { const t = this.initialPosition; this.position = t && K(t, this.container.canvas.size) ? t : this.calcPosition() } update(t) { var e, i, o; this.paused || (this.firstSpawn && (this.firstSpawn = !1, this.currentSpawnDelay = null !== (e = this.spawnDelay) && void 0 !== e ? e : 0, this.currentEmitDelay = null !== (i = this.emitDelay) && void 0 !== i ? i : 0, t.value = 0), void 0 !== this.duration && (this.currentDuration += t.value, this.currentDuration >= this.duration && (this.pause(), void 0 !== this.spawnDelay && delete this.spawnDelay, this.immortal || this.lifeCount--, this.lifeCount > 0 || this.immortal ? (this.position = this.calcPosition(), this.spawnDelay = 1e3 * (null !== (o = this.emitterOptions.life.delay) && void 0 !== o ? o : 0) / this.container.retina.reduceFactor) : this.destroy(), this.currentDuration -= this.duration, delete this.duration)), void 0 !== this.spawnDelay && (this.currentSpawnDelay += t.value, this.currentSpawnDelay >= this.spawnDelay && (this.play(), this.currentSpawnDelay -= this.currentSpawnDelay, delete this.spawnDelay)), void 0 !== this.emitDelay && (this.currentEmitDelay += t.value, this.currentEmitDelay >= this.emitDelay && (this.emit(), this.currentEmitDelay -= this.emitDelay))) } prepareToDie() { var t; if (this.paused) return; const e = null === (t = this.emitterOptions.life) || void 0 === t ? void 0 : t.duration; this.container.retina.reduceFactor && (this.lifeCount > 0 || this.immortal) && void 0 !== e && e > 0 && (this.duration = 1e3 * e) } destroy() { this.emitters.removeEmitter(this) } calcPosition() { var t, e; const i = this.container, o = this.emitterOptions.position; return { x: (null !== (t = null == o ? void 0 : o.x) && void 0 !== t ? t : 100 * Math.random()) / 100 * i.canvas.size.width, y: (null !== (e = null == o ? void 0 : o.y) && void 0 !== e ? e : 100 * Math.random()) / 100 * i.canvas.size.height } } emit() { var t; if (this.paused) return; const e = this.container, i = this.position, o = { x: this.size.mode === y.percent ? e.canvas.size.width * this.size.width / 100 : this.size.width, y: this.size.mode === y.percent ? e.canvas.size.height * this.size.height / 100 : this.size.height }, n = E(this.emitterOptions.rate.quantity); for (let s = 0; s < n; s++) { const n = it({}, this.particlesOptions); if (void 0 !== this.spawnColor) { const e = null === (t = this.emitterOptions.spawnColor) || void 0 === t ? void 0 : t.animation; if (e) { const t = e; if (t.enable) this.spawnColor.h = this.setColorAnimation(t, this.spawnColor.h, 360); else { const t = e; this.spawnColor.h = this.setColorAnimation(t.h, this.spawnColor.h, 360), this.spawnColor.s = this.setColorAnimation(t.s, this.spawnColor.s, 100), this.spawnColor.l = this.setColorAnimation(t.l, this.spawnColor.l, 100) } } n.color ? n.color.value = this.spawnColor : n.color = { value: this.spawnColor } } e.particles.addParticle(Go(i, o), n) } } setColorAnimation(t, e, i) { var o; const n = this.container; if (!t.enable) return e; const s = k(t.offset), a = 1e3 * E(this.emitterOptions.rate.delay) / n.retina.reduceFactor; return (e + (null !== (o = t.speed) && void 0 !== o ? o : 0) * n.fpsLimit / a + 3.6 * s) % i } } class To { constructor() { this.quantity = 1, this.delay = .1 } load(t) { void 0 !== t && (void 0 !== t.quantity && (this.quantity = z(t.quantity)), void 0 !== t.delay && (this.delay = z(t.delay))) } } class ko { load(t) { void 0 !== t && (void 0 !== t.count && (this.count = t.count), void 0 !== t.delay && (this.delay = t.delay), void 0 !== t.duration && (this.duration = t.duration)) } } class Eo { constructor() { this.autoPlay = !0, this.life = new ko, this.rate = new To } load(t) { void 0 !== t && (void 0 !== t.autoPlay && (this.autoPlay = t.autoPlay), void 0 !== t.size && (void 0 === this.size && (this.size = new Ao), this.size.load(t.size)), void 0 !== t.direction && (this.direction = t.direction), this.life.load(t.life), this.name = t.name, void 0 !== t.particles && (this.particles = it({}, t.particles)), this.rate.load(t.rate), void 0 !== t.position && (this.position = { x: t.position.x, y: t.position.y }), void 0 !== t.spawnColor && (void 0 === this.spawnColor && (this.spawnColor = new Be), this.spawnColor.load(t.spawnColor))) } } !function (t) { t.emitter = "emitter" }(po || (po = {})); class Ro { constructor(t) { this.container = t, this.array = [], this.emitters = [], this.interactivityEmitters = []; const e = t; e.getEmitter = t => void 0 === t || "number" == typeof t ? this.array[t || 0] : this.array.find((e => e.name === t)), e.addEmitter = (t, e) => this.addEmitter(t, e), e.playEmitter = t => { const i = e.getEmitter(t); i && i.externalPlay() }, e.pauseEmitter = t => { const i = e.getEmitter(t); i && i.externalPause() } } init(t) { var e, i; if (!t) return; t.emitters && (t.emitters instanceof Array ? this.emitters = t.emitters.map((t => { const e = new Eo; return e.load(t), e })) : (this.emitters instanceof Array && (this.emitters = new Eo), this.emitters.load(t.emitters))); const o = null === (i = null === (e = t.interactivity) || void 0 === e ? void 0 : e.modes) || void 0 === i ? void 0 : i.emitters; if (o && (o instanceof Array ? this.interactivityEmitters = o.map((t => { const e = new Eo; return e.load(t), e })) : (this.interactivityEmitters instanceof Array && (this.interactivityEmitters = new Eo), this.interactivityEmitters.load(o))), this.emitters instanceof Array) for (const t of this.emitters) this.addEmitter(t); else this.addEmitter(this.emitters) } play() { for (const t of this.array) t.play() } pause() { for (const t of this.array) t.pause() } stop() { this.array = [] } update(t) { for (const e of this.array) e.update(t) } handleClickMode(t) { const e = this.container, i = this.emitters, o = this.interactivityEmitters; if (t === po.emitter) { let t; o instanceof Array ? o.length > 0 && (t = Y(o)) : t = o; const n = null != t ? t : i instanceof Array ? Y(i) : i, s = e.interactivity.mouse.clickPosition; this.addEmitter(it({}, n), s) } } resize() { for (const t of this.array) t.resize() } addEmitter(t, e) { const i = new Oo(this, this.container, t, e); return this.array.push(i), i } removeEmitter(t) { const e = this.array.indexOf(t); e >= 0 && this.array.splice(e, 1) } } class Mo { constructor() { this.id = "emitters" } getPlugin(t) { return new Ro(t) } needsPlugin(t) { var e, i, o; if (void 0 === t) return !1; const n = t.emitters; return n instanceof Array && !!n.length || void 0 !== n || !!(null === (o = null === (i = null === (e = t.interactivity) || void 0 === e ? void 0 : e.events) || void 0 === i ? void 0 : i.onClick) || void 0 === o ? void 0 : o.mode) && Z(po.emitter, t.interactivity.events.onClick.mode) } loadOptions(t, e) { var i, o; if (!this.needsPlugin(t) && !this.needsPlugin(e)) return; const n = t; if (null == e ? void 0 : e.emitters) if ((null == e ? void 0 : e.emitters) instanceof Array) n.emitters = null == e ? void 0 : e.emitters.map((t => { const e = new Eo; return e.load(t), e })); else { let t = n.emitters; void 0 === (null == t ? void 0 : t.load) && (n.emitters = t = new Eo), t.load(null == e ? void 0 : e.emitters) } const s = null === (o = null === (i = null == e ? void 0 : e.interactivity) || void 0 === i ? void 0 : i.modes) || void 0 === o ? void 0 : o.emitters; if (s) if (s instanceof Array) n.interactivity.modes.emitters = s.map((t => { const e = new Eo; return e.load(t), e })); else { let t = n.interactivity.modes.emitters; void 0 === (null == t ? void 0 : t.load) && (n.interactivity.modes.emitters = t = new Eo), t.load(s) } } } !function (t) { t.equidistant = "equidistant", t.onePerPoint = "one-per-point", t.perPoint = "per-point", t.randomLength = "random-length", t.randomPoint = "random-point" }(vo || (vo = {})), function (t) { t.path = "path", t.radius = "radius" }(go || (go = {})), function (t) { t.inline = "inline", t.inside = "inside", t.outside = "outside", t.none = "none" }(yo || (yo = {})); class zo { constructor() { this.color = new ve, this.width = .5, this.opacity = 1 } load(t) { var e; void 0 !== t && (this.color = ve.create(this.color, t.color), "string" == typeof this.color.value && (this.opacity = null !== (e = yt(this.color.value)) && void 0 !== e ? e : this.opacity), void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.width && (this.width = t.width)) } } class Lo { constructor() { this.enable = !1, this.stroke = new zo } get lineWidth() { return this.stroke.width } set lineWidth(t) { this.stroke.width = t } get lineColor() { return this.stroke.color } set lineColor(t) { this.stroke.color = ve.create(this.stroke.color, t) } load(t) { var e; if (void 0 !== t) { void 0 !== t.enable && (this.enable = t.enable); const i = null !== (e = t.stroke) && void 0 !== e ? e : { color: t.lineColor, width: t.lineWidth }; this.stroke.load(i) } } } class Io { constructor() { this.radius = 10, this.type = go.path } load(t) { void 0 !== t && (void 0 !== t.radius && (this.radius = t.radius), void 0 !== t.type && (this.type = t.type)) } } class Ho { constructor() { this.arrangement = vo.onePerPoint } load(t) { void 0 !== t && void 0 !== t.arrangement && (this.arrangement = t.arrangement) } } class Do { constructor() { this.path = [], this.size = { height: 0, width: 0 } } load(t) { void 0 !== t && (void 0 !== t.path && (this.path = t.path), void 0 !== t.size && (void 0 !== t.size.width && (this.size.width = t.size.width), void 0 !== t.size.height && (this.size.height = t.size.height))) } } class Fo { constructor() { this.draw = new Lo, this.enable = !1, this.inline = new Ho, this.move = new Io, this.scale = 1, this.type = yo.none } get inlineArrangement() { return this.inline.arrangement } set inlineArrangement(t) { this.inline.arrangement = t } load(t) { var e; if (void 0 !== t) { this.draw.load(t.draw); const i = null !== (e = t.inline) && void 0 !== e ? e : { arrangement: t.inlineArrangement }; void 0 !== i && this.inline.load(i), this.move.load(t.move), void 0 !== t.scale && (this.scale = t.scale), void 0 !== t.type && (this.type = t.type), void 0 !== t.enable ? this.enable = t.enable : this.enable = this.type !== yo.none, void 0 !== t.url && (this.url = t.url), void 0 !== t.data && ("string" == typeof t.data ? this.data = t.data : (this.data = new Do, this.data.load(t.data))), void 0 !== t.position && (this.position = it({}, t.position)) } } } var No = function (t, e, i, o) { return new (i || (i = Promise))((function (n, s) { function a(t) { try { l(o.next(t)) } catch (t) { s(t) } } function r(t) { try { l(o.throw(t)) } catch (t) { s(t) } } function l(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i((function (t) { t(e) }))).then(a, r) } l((o = o.apply(t, e || [])).next()) })) }; function Bo(t, e, i) { const o = pt(i.color); if (o) { t.beginPath(), t.moveTo(e[0].x, e[0].y); for (const i of e) t.lineTo(i.x, i.y); t.closePath(), t.strokeStyle = Ot(o), t.lineWidth = i.width, t.stroke() } } function jo(t, e, i, o) { t.translate(o.x, o.y); const n = pt(i.color); n && (t.strokeStyle = Ot(n, i.opacity), t.lineWidth = i.width, t.stroke(e)) } function qo(t, e, i) { const { dx: o, dy: n } = I(i, t), { dx: s, dy: a } = I(e, t), r = (o * s + n * a) / (Math.pow(s, 2) + Math.pow(a, 2)); let l = t.x + s * r, c = t.y + a * r; return r < 0 ? (l = t.x, c = t.y) : r > 1 && (l = e.x, c = e.y), { x: l, y: c, isOnSegment: r >= 0 && r <= 1 } } function Uo(t, e, i) { const { dx: o, dy: n } = I(t, e), s = Math.atan2(n, o), a = Math.sin(s), r = -Math.cos(s), l = 2 * (i.x * a + i.y * r); i.x -= l * a, i.y -= l * r } class Qo { constructor(t) { this.container = t, this.dimension = { height: 0, width: 0 }, this.path2DSupported = !!window.Path2D, this.options = new Fo, this.polygonMaskMoveRadius = this.options.move.radius * t.retina.pixelRatio } initAsync(t) { return No(this, void 0, void 0, (function* () { this.options.load(null == t ? void 0 : t.polygon); const e = this.options; this.polygonMaskMoveRadius = e.move.radius * this.container.retina.pixelRatio, e.enable && (yield this.initRawData()) })) } resize() { const t = this.container, e = this.options; e.enable && e.type !== yo.none && (this.redrawTimeout && clearTimeout(this.redrawTimeout), this.redrawTimeout = window.setTimeout((() => No(this, void 0, void 0, (function* () { yield this.initRawData(!0), t.particles.redraw() }))), 250)) } stop() { delete this.raw, delete this.paths } particlesInitialization() { const t = this.options; return !(!t.enable || t.type !== yo.inline || t.inline.arrangement !== vo.onePerPoint && t.inline.arrangement !== vo.perPoint) && (this.drawPoints(), !0) } particlePosition(t) { var e, i; if (this.options.enable && (null !== (i = null === (e = this.raw) || void 0 === e ? void 0 : e.length) && void 0 !== i ? i : 0) > 0) return it({}, t || this.randomPoint()) } particleBounce(t, e, i) { return this.polygonBounce(t, e, i) } clickPositionValid(t) { const e = this.options; return e.enable && e.type !== yo.none && e.type !== yo.inline && this.checkInsidePolygon(t) } draw(t) { var e; if (!(null === (e = this.paths) || void 0 === e ? void 0 : e.length)) return; const i = this.options, o = i.draw; if (!i.enable || !o.enable) return; const n = this.raw; for (const e of this.paths) { const i = e.path2d, s = this.path2DSupported; t && (s && i && this.offset ? jo(t, i, o.stroke, this.offset) : n && Bo(t, n, o.stroke)) } } polygonBounce(t, e, i) { const o = this.options; if (!this.raw || !o.enable || i !== l.top) return !1; if (o.type === yo.inside || o.type === yo.outside) { let e, i, o; const n = t.getPosition(), s = t.getRadius(); for (let a = 0, r = this.raw.length - 1; a < this.raw.length; r = a++) { const l = this.raw[a], c = this.raw[r]; e = qo(l, c, n); const h = I(n, e); if ([i, o] = [h.dx, h.dy], h.distance < s) return Uo(l, c, t.velocity), !0 } if (e && void 0 !== i && void 0 !== o && !this.checkInsidePolygon(n)) { const i = { x: 1, y: 1 }; return t.position.x >= e.x && (i.x = -1), t.position.y >= e.y && (i.y = -1), t.position.x = e.x + 2 * s * i.x, t.position.y = e.y + 2 * s * i.y, t.velocity.mult(-1), !0 } } else if (o.type === yo.inline && t.initialPosition) { if (H(t.initialPosition, t.getPosition()) > this.polygonMaskMoveRadius) return t.velocity.x = t.velocity.y / 2 - t.velocity.x, t.velocity.y = t.velocity.x / 2 - t.velocity.y, !0 } return !1 } checkInsidePolygon(t) { var e, i; const o = this.container, n = this.options; if (!n.enable || n.type === yo.none || n.type === yo.inline) return !0; if (!this.raw) throw new Error(ht.noPolygonFound); const s = o.canvas.size, a = null !== (e = null == t ? void 0 : t.x) && void 0 !== e ? e : Math.random() * s.width, r = null !== (i = null == t ? void 0 : t.y) && void 0 !== i ? i : Math.random() * s.height; let l = !1; for (let t = 0, e = this.raw.length - 1; t < this.raw.length; e = t++) { const i = this.raw[t], o = this.raw[e]; i.y > r != o.y > r && a < (o.x - i.x) * (r - i.y) / (o.y - i.y) + i.x && (l = !l) } return n.type === yo.inside ? l : n.type === yo.outside && !l } parseSvgPath(t, e) { var i, o, n; const s = null != e && e; if (void 0 !== this.paths && !s) return this.raw; const a = this.container, r = this.options, l = (new DOMParser).parseFromString(t, "image/svg+xml"), c = l.getElementsByTagName("svg")[0]; let h = c.getElementsByTagName("path"); h.length || (h = l.getElementsByTagName("path")), this.paths = []; for (let t = 0; t < h.length; t++) { const e = h.item(t); e && this.paths.push({ element: e, length: e.getTotalLength() }) } const d = a.retina.pixelRatio, u = r.scale / d; this.dimension.width = parseFloat(null !== (i = c.getAttribute("width")) && void 0 !== i ? i : "0") * u, this.dimension.height = parseFloat(null !== (o = c.getAttribute("height")) && void 0 !== o ? o : "0") * u; const p = null !== (n = r.position) && void 0 !== n ? n : { x: 50, y: 50 }; return this.offset = { x: a.canvas.size.width * p.x / (100 * d) - this.dimension.width / 2, y: a.canvas.size.height * p.y / (100 * d) - this.dimension.height / 2 }, function (t, e, i) { const o = []; for (const n of t) { const t = n.element.pathSegList, s = t.numberOfItems, a = { x: 0, y: 0 }; for (let n = 0; n < s; n++) { const s = t.getItem(n), r = window.SVGPathSeg; switch (s.pathSegType) { case r.PATHSEG_MOVETO_ABS: case r.PATHSEG_LINETO_ABS: case r.PATHSEG_CURVETO_CUBIC_ABS: case r.PATHSEG_CURVETO_QUADRATIC_ABS: case r.PATHSEG_ARC_ABS: case r.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: case r.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: { const t = s; a.x = t.x, a.y = t.y; break } case r.PATHSEG_LINETO_HORIZONTAL_ABS: a.x = s.x; break; case r.PATHSEG_LINETO_VERTICAL_ABS: a.y = s.y; break; case r.PATHSEG_LINETO_REL: case r.PATHSEG_MOVETO_REL: case r.PATHSEG_CURVETO_CUBIC_REL: case r.PATHSEG_CURVETO_QUADRATIC_REL: case r.PATHSEG_ARC_REL: case r.PATHSEG_CURVETO_CUBIC_SMOOTH_REL: case r.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: { const t = s; a.x += t.x, a.y += t.y; break } case r.PATHSEG_LINETO_HORIZONTAL_REL: a.x += s.x; break; case r.PATHSEG_LINETO_VERTICAL_REL: a.y += s.y; break; case r.PATHSEG_UNKNOWN: case r.PATHSEG_CLOSEPATH: continue }o.push({ x: a.x * e + i.x, y: a.y * e + i.y }) } } return o }(this.paths, u, this.offset) } downloadSvgPath(t, e) { return No(this, void 0, void 0, (function* () { const i = this.options, o = t || i.url, n = null != e && e; if (!o || void 0 !== this.paths && !n) return this.raw; const s = yield fetch(o); if (!s.ok) throw new Error("tsParticles Error - Error occurred during polygon mask download"); return this.parseSvgPath(yield s.text(), e) })) } drawPoints() { if (this.raw) for (const t of this.raw) this.container.particles.addParticle({ x: t.x, y: t.y }) } randomPoint() { const t = this.container, e = this.options; let i; if (e.type === yo.inline) switch (e.inline.arrangement) { case vo.randomPoint: i = this.getRandomPoint(); break; case vo.randomLength: i = this.getRandomPointByLength(); break; case vo.equidistant: i = this.getEquidistantPointByIndex(t.particles.count); break; case vo.onePerPoint: case vo.perPoint: default: i = this.getPointByIndex(t.particles.count) } else i = { x: Math.random() * t.canvas.size.width, y: Math.random() * t.canvas.size.height }; return this.checkInsidePolygon(i) ? i : this.randomPoint() } getRandomPoint() { if (!this.raw || !this.raw.length) throw new Error(ht.noPolygonDataLoaded); const t = Y(this.raw); return { x: t.x, y: t.y } } getRandomPointByLength() { var t, e, i; const o = this.options; if (!this.raw || !this.raw.length || !(null === (t = this.paths) || void 0 === t ? void 0 : t.length)) throw new Error(ht.noPolygonDataLoaded); const n = Y(this.paths), s = Math.floor(Math.random() * n.length) + 1, a = n.element.getPointAtLength(s); return { x: a.x * o.scale + ((null === (e = this.offset) || void 0 === e ? void 0 : e.x) || 0), y: a.y * o.scale + ((null === (i = this.offset) || void 0 === i ? void 0 : i.y) || 0) } } getEquidistantPointByIndex(t) { var e, i, o, n, s, a, r; const l = this.container.actualOptions, c = this.options; if (!this.raw || !this.raw.length || !(null === (e = this.paths) || void 0 === e ? void 0 : e.length)) throw new Error(ht.noPolygonDataLoaded); let h, d = 0; const u = this.paths.reduce(((t, e) => t + e.length), 0) / l.particles.number.value; for (const e of this.paths) { const i = u * t - d; if (i <= e.length) { h = e.element.getPointAtLength(i); break } d += e.length } return { x: (null !== (i = null == h ? void 0 : h.x) && void 0 !== i ? i : 0) * c.scale + (null !== (n = null === (o = this.offset) || void 0 === o ? void 0 : o.x) && void 0 !== n ? n : 0), y: (null !== (s = null == h ? void 0 : h.y) && void 0 !== s ? s : 0) * c.scale + (null !== (r = null === (a = this.offset) || void 0 === a ? void 0 : a.y) && void 0 !== r ? r : 0) } } getPointByIndex(t) { if (!this.raw || !this.raw.length) throw new Error(ht.noPolygonDataLoaded); const e = this.raw[t % this.raw.length]; return { x: e.x, y: e.y } } createPath2D() { var t, e; const i = this.options; if (this.path2DSupported && (null === (t = this.paths) || void 0 === t ? void 0 : t.length)) for (const t of this.paths) { const o = null === (e = t.element) || void 0 === e ? void 0 : e.getAttribute("d"); if (o) { const e = new Path2D(o), n = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix(), s = new Path2D, a = n.scale(i.scale); s.addPath ? (s.addPath(e, a), t.path2d = s) : delete t.path2d } else delete t.path2d; !t.path2d && this.raw && (t.path2d = new Path2D, t.path2d.moveTo(this.raw[0].x, this.raw[0].y), this.raw.forEach(((e, i) => { var o; i > 0 && (null === (o = t.path2d) || void 0 === o || o.lineTo(e.x, e.y)) })), t.path2d.closePath()) } } initRawData(t) { return No(this, void 0, void 0, (function* () { const e = this.options; if (e.url) this.raw = yield this.downloadSvgPath(e.url, t); else if (e.data) { const i = e.data; let o; if ("string" != typeof i) { const t = i.path instanceof Array ? i.path.map((t => `<path d="${t}" />`)).join("") : `<path d="${i.path}" />`; o = `<svg ${'xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"'} width="${i.size.width}" height="${i.size.height}">${t}</svg>` } else o = i; this.raw = this.parseSvgPath(o, t) } this.createPath2D() })) } } class Wo { constructor() { this.id = "polygonMask" } getPlugin(t) { return new Qo(t) } needsPlugin(t) { var e, i, o; return null !== (i = null === (e = null == t ? void 0 : t.polygon) || void 0 === e ? void 0 : e.enable) && void 0 !== i ? i : void 0 !== (null === (o = null == t ? void 0 : t.polygon) || void 0 === o ? void 0 : o.type) && t.polygon.type !== yo.none } loadOptions(t, e) { if (!this.needsPlugin(e)) return; const i = t; let o = i.polygon; void 0 === (null == o ? void 0 : o.load) && (i.polygon = o = new Fo), o.load(null == e ? void 0 : e.polygon) } } class $o { getSidesCount() { return 12 } draw(t, e, i) { t.arc(0, 0, i, 0, 2 * Math.PI, !1) } } var Zo = function (t, e, i, o) { return new (i || (i = Promise))((function (n, s) { function a(t) { try { l(o.next(t)) } catch (t) { s(t) } } function r(t) { try { l(o.throw(t)) } catch (t) { s(t) } } function l(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i((function (t) { t(e) }))).then(a, r) } l((o = o.apply(t, e || [])).next()) })) }; function Jo(t) { return new Promise(((e, i) => { if (!t) return void i("Error tsParticles - No image.src"); const o = { source: t, type: t.substr(t.length - 3) }, n = new Image; n.addEventListener("load", (() => { o.element = n, e(o) })), n.addEventListener("error", (() => { i(`Error tsParticles - loading image: ${t}`) })), n.src = t })) } function Xo(t) { return Zo(this, void 0, void 0, (function* () { if (!t) throw new Error("Error tsParticles - No image.src"); const e = { source: t, type: t.substr(t.length - 3) }; if ("svg" !== e.type) return Jo(t); const i = yield fetch(e.source); if (!i.ok) throw new Error("Error tsParticles - Image not found"); return e.svgData = yield i.text(), e })) } var Yo, Ko = function (t, e, i, o) { return new (i || (i = Promise))((function (n, s) { function a(t) { try { l(o.next(t)) } catch (t) { s(t) } } function r(t) { try { l(o.throw(t)) } catch (t) { s(t) } } function l(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i((function (t) { t(e) }))).then(a, r) } l((o = o.apply(t, e || [])).next()) })) }, tn = function (t, e, i, o, n) { if ("m" === o) throw new TypeError("Private method is not writable"); if ("a" === o && !n) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === o ? n.call(t, i) : n ? n.value = i : e.set(t, i), i }, en = function (t, e, i, o) { if ("a" === i && !o) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !o : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === i ? o : "a" === i ? o.call(t) : o ? o.value : e.get(t) }; class on { constructor() { Yo.set(this, void 0), tn(this, Yo, [], "f") } getSidesCount() { return 12 } getImages(t) { const e = en(this, Yo, "f").find((e => e.id === t.id)); return e || (en(this, Yo, "f").push({ id: t.id, images: [] }), this.getImages(t)) } addImage(t, e) { const i = this.getImages(t); null == i || i.images.push(e) } init(t) { return Ko(this, void 0, void 0, (function* () { yield this.loadImagesFromParticlesOptions(t, t.actualOptions.particles), yield this.loadImagesFromParticlesOptions(t, t.actualOptions.interactivity.modes.trail.particles); for (const e of t.actualOptions.manualParticles) yield this.loadImagesFromParticlesOptions(t, e.options); const e = t.actualOptions; if (e.emitters) if (e.emitters instanceof Array) for (const i of e.emitters) yield this.loadImagesFromParticlesOptions(t, i.particles); else yield this.loadImagesFromParticlesOptions(t, e.emitters.particles); const i = e.interactivity.modes.emitters; if (i) if (i instanceof Array) for (const e of i) yield this.loadImagesFromParticlesOptions(t, e.particles); else yield this.loadImagesFromParticlesOptions(t, i.particles) })) } destroy() { tn(this, Yo, [], "f") } loadImagesFromParticlesOptions(t, e) { var i, o, n; return Ko(this, void 0, void 0, (function* () { const s = null == e ? void 0 : e.shape; if (!(null == s ? void 0 : s.type) || !s.options || !Z(P.image, s.type) && !Z(P.images, s.type)) return; const a = en(this, Yo, "f").findIndex((e => e.id === t.id)); a >= 0 && en(this, Yo, "f").splice(a, 1); const r = null !== (i = s.options[P.images]) && void 0 !== i ? i : s.options[P.image]; if (r instanceof Array) for (const e of r) yield this.loadImageShape(t, e); else yield this.loadImageShape(t, r); if (null == e ? void 0 : e.groups) for (const i in e.groups) { const o = e.groups[i]; yield this.loadImagesFromParticlesOptions(t, o) } (null === (n = null === (o = null == e ? void 0 : e.destroy) || void 0 === o ? void 0 : o.split) || void 0 === n ? void 0 : n.particles) && (yield this.loadImagesFromParticlesOptions(t, null == e ? void 0 : e.destroy.split.particles)) })) } loadImageShape(t, e) { return Ko(this, void 0, void 0, (function* () { try { const i = e.replaceColor ? Xo : Jo, o = yield i(e.src); o && this.addImage(t, o) } catch (t) { console.warn(`tsParticles error - ${e.src} not found`) } })) } draw(t, e, i, o) { var n, s; if (!t) return; const a = e.image, r = null === (n = null == a ? void 0 : a.data) || void 0 === n ? void 0 : n.element; if (!r) return; const l = null !== (s = null == a ? void 0 : a.ratio) && void 0 !== s ? s : 1, c = { x: -i, y: -i }; (null == a ? void 0 : a.data.svgData) && (null == a ? void 0 : a.replaceColor) || (t.globalAlpha = o), t.drawImage(r, c.x, c.y, 2 * i, 2 * i / l), (null == a ? void 0 : a.data.svgData) && (null == a ? void 0 : a.replaceColor) || (t.globalAlpha = 1) } loadShape(t) { var e, i, o, n, s; if ("image" !== t.shape && "images" !== t.shape) return; const a = t.container, r = this.getImages(a).images, l = t.shapeData, c = null !== (e = r.find((t => t.source === l.src))) && void 0 !== e ? e : r[0], h = t.getFillColor(); let d; if (!c) return; if (void 0 !== c.svgData && l.replaceColor && h) { const e = function (t, e, i) { const { svgData: o } = t; if (!o) return ""; if (o.includes("fill")) { const t = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d.]+%?\))|currentcolor/gi; return o.replace(t, (() => Tt(e, i))) } const n = o.indexOf(">"); return `${o.substring(0, n)} fill="${Tt(e, i)}"${o.substring(n)}` }(c, h, t.opacity.value), o = new Blob([e], { type: "image/svg+xml" }), n = URL || window.URL || window.webkitURL || window, s = n.createObjectURL(o), a = new Image; d = { data: Object.assign(Object.assign({}, c), { svgData: e }), ratio: l.width / l.height, replaceColor: null !== (i = l.replaceColor) && void 0 !== i ? i : l.replace_color, source: l.src }, a.addEventListener("load", (() => { const e = t.image; e && (e.loaded = !0, c.element = a), n.revokeObjectURL(s) })), a.addEventListener("error", (() => { n.revokeObjectURL(s), Jo(l.src).then((e => { const i = t.image; i && (c.element = null == e ? void 0 : e.element, i.loaded = !0) })) })), a.src = s } else d = { data: c, loaded: !0, ratio: l.width / l.height, replaceColor: null !== (o = l.replaceColor) && void 0 !== o ? o : l.replace_color, source: l.src }; d.ratio || (d.ratio = 1); const u = { image: d, fill: null !== (n = l.fill) && void 0 !== n ? n : t.fill, close: null !== (s = l.close) && void 0 !== s ? s : t.close }; t.image = u.image, t.fill = u.fill, t.close = u.close } } Yo = new WeakMap; class nn { getSidesCount() { return 1 } draw(t, e, i) { t.moveTo(-i / 2, 0), t.lineTo(i / 2, 0) } } class sn { getSidesCount(t) { var e, i; const o = t.shapeData; return null !== (i = null !== (e = null == o ? void 0 : o.sides) && void 0 !== e ? e : null == o ? void 0 : o.nb_sides) && void 0 !== i ? i : 5 } draw(t, e, i) { const o = this.getCenter(e, i), n = this.getSidesData(e, i), s = n.count.numerator * n.count.denominator, a = n.count.numerator / n.count.denominator, r = 180 * (a - 2) / a, l = Math.PI - Math.PI * r / 180; if (t) { t.beginPath(), t.translate(o.x, o.y), t.moveTo(0, 0); for (let e = 0; e < s; e++)t.lineTo(n.length, 0), t.translate(n.length, 0), t.rotate(l) } } } class an extends sn { getSidesData(t, e) { var i, o; const n = t.shapeData, s = null !== (o = null !== (i = null == n ? void 0 : n.sides) && void 0 !== i ? i : null == n ? void 0 : n.nb_sides) && void 0 !== o ? o : 5; return { count: { denominator: 1, numerator: s }, length: 2.66 * e / (s / 3) } } getCenter(t, e) { return { x: -e / (this.getSidesCount(t) / 3.5), y: -e / .76 } } } class rn extends sn { getSidesCount() { return 3 } getSidesData(t, e) { return { count: { denominator: 2, numerator: 3 }, length: 2 * e } } getCenter(t, e) { return { x: -e, y: e / 1.66 } } } function ln(t) { !function (t) { t.addShape("polygon", new an) }(t), function (t) { t.addShape("triangle", new rn) }(t) } const cn = Math.sqrt(2); class hn { getSidesCount() { return 4 } draw(t, e, i) { t.rect(-i / cn, -i / cn, 2 * i / cn, 2 * i / cn) } } class dn { getSidesCount(t) { var e, i; const o = t.shapeData; return null !== (i = null !== (e = null == o ? void 0 : o.sides) && void 0 !== e ? e : null == o ? void 0 : o.nb_sides) && void 0 !== i ? i : 5 } draw(t, e, i) { var o; const n = e.shapeData, s = this.getSidesCount(e), a = null !== (o = null == n ? void 0 : n.inset) && void 0 !== o ? o : 2; t.moveTo(0, 0 - i); for (let e = 0; e < s; e++)t.rotate(Math.PI / s), t.lineTo(0, 0 - i * a), t.rotate(Math.PI / s), t.lineTo(0, 0 - i) } } var un = function (t, e, i, o) { return new (i || (i = Promise))((function (n, s) { function a(t) { try { l(o.next(t)) } catch (t) { s(t) } } function r(t) { try { l(o.throw(t)) } catch (t) { s(t) } } function l(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i((function (t) { t(e) }))).then(a, r) } l((o = o.apply(t, e || [])).next()) })) }; const pn = ["text", "character", "char"]; class vn { getSidesCount() { return 12 } init(t) { return un(this, void 0, void 0, (function* () { const e = t.actualOptions; if (pn.find((t => Z(t, e.particles.shape.type)))) { const t = pn.map((t => e.particles.shape.options[t])).find((t => !!t)); if (t instanceof Array) { const e = []; for (const i of t) e.push(J(i)); yield Promise.allSettled(e) } else void 0 !== t && (yield J(t)) } })) } draw(t, e, i, o) { var n, s, a; const r = e.shapeData; if (void 0 === r) return; const l = r.value; if (void 0 === l) return; const c = e; void 0 === c.text && (c.text = l instanceof Array ? Y(l, e.randomIndexData) : l); const h = c.text, d = null !== (n = r.style) && void 0 !== n ? n : "", u = null !== (s = r.weight) && void 0 !== s ? s : "400", p = 2 * Math.round(i), v = null !== (a = r.font) && void 0 !== a ? a : "Verdana", g = e.fill, y = h.length * i / 2; t.font = `${d} ${u} ${p}px "${v}"`; const f = { x: -y, y: i / 2 }; t.globalAlpha = o, g ? t.fillText(h, f.x, f.y) : t.strokeText(h, f.x, f.y), t.globalAlpha = 1 } } class gn { isEnabled(t) { const e = t.options.rotate, i = e.animation; return !t.destroyed && !t.spawning && !e.path && i.enable } update(t, e) { this.isEnabled(t) && function (t, e) { var i; const o = t.options.rotate.animation, n = (null !== (i = t.rotate.velocity) && void 0 !== i ? i : 0) * e.factor, s = 2 * Math.PI; if (o.enable) switch (t.rotate.status) { case m.increasing: t.rotate.value += n, t.rotate.value > s && (t.rotate.value -= s); break; case m.decreasing: default: t.rotate.value -= n, t.rotate.value < 0 && (t.rotate.value += s) } }(t, e) } } function yn(t, e, i, o, n) { var s; const a = e; if (!a || !i.enable) return; const r = k(i.offset), l = (null !== (s = e.velocity) && void 0 !== s ? s : 0) * t.factor + 3.6 * r; n && a.status !== m.increasing ? (a.value -= l, a.value < 0 && (a.status = m.increasing, a.value += a.value)) : (a.value += l, n && a.value > o && (a.status = m.decreasing, a.value -= a.value % o)), a.value > o && (a.value %= o) } class fn { isEnabled(t) { var e, i, o; const n = t.options.color.animation; return !t.destroyed && !t.spawning && (void 0 !== (null === (e = t.color) || void 0 === e ? void 0 : e.h.value) && n.h.enable || void 0 !== (null === (i = t.color) || void 0 === i ? void 0 : i.s.value) && n.s.enable || void 0 !== (null === (o = t.color) || void 0 === o ? void 0 : o.l.value) && n.l.enable) } update(t, e) { !function (t, e) { var i, o, n; const s = t.options.color.animation; void 0 !== (null === (i = t.color) || void 0 === i ? void 0 : i.h) && yn(e, t.color.h, s.h, 360, !1), void 0 !== (null === (o = t.color) || void 0 === o ? void 0 : o.s) && yn(e, t.color.s, s.s, 100, !0), void 0 !== (null === (n = t.color) || void 0 === n ? void 0 : n.l) && yn(e, t.color.l, s.l, 100, !0) }(t, e) } } class mn { constructor(t) { this.container = t } isEnabled(t) { return !t.destroyed } update(t, e) { if (!this.isEnabled(t)) return; const i = t.life; let o = !1; if (t.spawning) { if (i.delayTime += e.value, !(i.delayTime >= t.life.delay)) return; o = !0, t.spawning = !1, i.delayTime = 0, i.time = 0 } if (-1 === i.duration) return; if (t.spawning) return; if (o ? i.time = 0 : i.time += e.value, i.time < i.duration) return; if (i.time = 0, t.life.count > 0 && t.life.count--, 0 === t.life.count) return void t.destroy(); const n = this.container.canvas.size, s = z(0, n.width), a = z(0, n.width); t.position.x = k(s), t.position.y = k(a), t.spawning = !0, i.delayTime = 0, i.time = 0, t.reset(); const r = t.options.life; i.delay = 1e3 * E(r.delay.value), i.duration = 1e3 * E(r.duration.value) } } function wn(t, e) { var i, o; const n = t.options.opacity.animation, s = t.opacity.min, a = t.opacity.max; if (!t.destroyed && n.enable && (n.count <= 0 || t.loops.opacity < n.count)) { switch (t.opacity.status) { case m.increasing: t.opacity.value >= a ? (t.opacity.status = m.decreasing, t.loops.opacity++) : t.opacity.value += (null !== (i = t.opacity.velocity) && void 0 !== i ? i : 0) * e.factor; break; case m.decreasing: t.opacity.value <= s ? (t.opacity.status = m.increasing, t.loops.opacity++) : t.opacity.value -= (null !== (o = t.opacity.velocity) && void 0 !== o ? o : 0) * e.factor }!function (t, e, i, o, n) { switch (e) { case b.max: i >= n && t.destroy(); break; case b.min: i <= o && t.destroy() } }(t, n.destroy, t.opacity.value, s, a), t.destroyed || (t.opacity.value = O(t.opacity.value, s, a)) } } class bn { isEnabled(t) { const e = t.options.opacity.anim; return !t.destroyed && !t.spawning && e.enable && (e.count <= 0 || t.loops.opacity < e.count) } update(t, e) { this.isEnabled(t) && wn(t, e) } } function Sn(t, e) { var i; const o = t.options.size.animation, n = (null !== (i = t.size.velocity) && void 0 !== i ? i : 0) * e.factor, s = t.size.min, a = t.size.max; if (!t.destroyed && o.enable && (o.count <= 0 || t.loops.size < o.count)) { switch (t.size.status) { case m.increasing: t.size.value >= a ? (t.size.status = m.decreasing, t.loops.size++) : t.size.value += n; break; case m.decreasing: t.size.value <= s ? (t.size.status = m.increasing, t.loops.size++) : t.size.value -= n }!function (t, e, i, o, n) { switch (e) { case b.max: i >= n && t.destroy(); break; case b.min: i <= o && t.destroy() } }(t, o.destroy, t.size.value, s, a), t.destroyed || (t.size.value = O(t.size.value, s, a)) } } class Pn { isEnabled(t) { const e = t.options.size.animation; return !t.destroyed && !t.spawning && e.enable && (e.count <= 0 || t.loops.size < e.count) } update(t, e) { this.isEnabled(t) && Sn(t, e) } } function _n(t, e, i, o, n) { var s; const a = e; if (!a || !i.enable) return; const r = k(i.offset), l = (null !== (s = e.velocity) && void 0 !== s ? s : 0) * t.factor + 3.6 * r; n && a.status !== m.increasing ? (a.value -= l, a.value < 0 && (a.status = m.increasing, a.value += a.value)) : (a.value += l, n && a.value > o && (a.status = m.decreasing, a.value -= a.value % o)), a.value > o && (a.value %= o) } class xn { isEnabled(t) { var e, i, o; const n = t.stroke.color; return !t.destroyed && !t.spawning && void 0 !== n && (void 0 !== (null === (e = t.strokeColor) || void 0 === e ? void 0 : e.h.value) && n.animation.h.enable || void 0 !== (null === (i = t.strokeColor) || void 0 === i ? void 0 : i.s.value) && n.animation.s.enable || void 0 !== (null === (o = t.strokeColor) || void 0 === o ? void 0 : o.l.value) && n.animation.l.enable) } update(t, e) { this.isEnabled(t) && function (t, e) { var i, o, n, s, a, r, l, c, h, d, u, p; if (!t.stroke.color) return; const v = t.stroke.color.animation, g = v; if (void 0 !== g.enable) { const s = null !== (o = null === (i = t.strokeColor) || void 0 === i ? void 0 : i.h) && void 0 !== o ? o : null === (n = t.color) || void 0 === n ? void 0 : n.h; s && _n(e, s, g, 360, !1) } else { const i = v, o = null !== (a = null === (s = t.strokeColor) || void 0 === s ? void 0 : s.h) && void 0 !== a ? a : null === (r = t.color) || void 0 === r ? void 0 : r.h; o && _n(e, o, i.h, 360, !1); const n = null !== (c = null === (l = t.strokeColor) || void 0 === l ? void 0 : l.s) && void 0 !== c ? c : null === (h = t.color) || void 0 === h ? void 0 : h.s; n && _n(e, n, i.s, 100, !0); const g = null !== (u = null === (d = t.strokeColor) || void 0 === d ? void 0 : d.l) && void 0 !== u ? u : null === (p = t.color) || void 0 === p ? void 0 : p.l; g && _n(e, g, i.l, 100, !0) } }(t, e) } } class Cn { constructor(t) { this.container = t } isEnabled(t) { return !t.destroyed && !t.spawning } update(t, e) { var i, o, n, s; const a = t.options.move.outModes; this.updateOutMode(t, e, null !== (i = a.bottom) && void 0 !== i ? i : a.default, l.bottom), this.updateOutMode(t, e, null !== (o = a.left) && void 0 !== o ? o : a.default, l.left), this.updateOutMode(t, e, null !== (n = a.right) && void 0 !== n ? n : a.default, l.right), this.updateOutMode(t, e, null !== (s = a.top) && void 0 !== s ? s : a.default, l.top) } updateOutMode(t, e, i, o) { switch (i) { case g.bounce: case g.bounceVertical: case g.bounceHorizontal: case "bounceVertical": case "bounceHorizontal": case g.split: this.bounce(t, e, o, i); break; case g.destroy: this.destroy(t, o); break; case g.out: this.out(t, o); break; case g.none: default: this.none(t, o) } } destroy(t, e) { const i = this.container; K(t.position, i.canvas.size, t.getRadius(), e) || i.particles.remove(t, void 0, !0) } out(t, e) { const i = this.container; if (K(t.position, i.canvas.size, t.getRadius(), e)) return; const o = t.options.move.warp, n = i.canvas.size, s = { bottom: n.height + t.offset.y, left: -t.offset.x, right: n.width + t.offset.x, top: -t.offset.y }, a = t.getRadius(), r = et(t.position, a); e === l.right && r.left > n.width + t.offset.x ? (t.position.x = s.left, t.initialPosition.x = t.position.x, o || (t.position.y = Math.random() * n.height, t.initialPosition.y = t.position.y)) : e === l.left && r.right < -t.offset.x && (t.position.x = s.right, t.initialPosition.x = t.position.x, o || (t.position.y = Math.random() * n.height, t.initialPosition.y = t.position.y)), e === l.bottom && r.top > n.height + t.offset.y ? (o || (t.position.x = Math.random() * n.width, t.initialPosition.x = t.position.x), t.position.y = s.top, t.initialPosition.y = t.position.y) : e === l.top && r.bottom < -t.offset.y && (o || (t.position.x = Math.random() * n.width, t.initialPosition.x = t.position.x), t.position.y = s.bottom, t.initialPosition.y = t.position.y) } bounce(t, e, i, o) { const n = this.container; let s = !1; for (const [, o] of n.plugins) if (void 0 !== o.particleBounce && (s = o.particleBounce(t, e, i)), s) break; if (s) return; const a = t.getPosition(), r = t.offset, c = t.getRadius(), h = et(a, c), d = n.canvas.size; !function (t) { if (t.outMode !== g.bounce && t.outMode !== g.bounceHorizontal && "bounceHorizontal" !== t.outMode && t.outMode !== g.split) return; const e = t.particle.velocity.x; let i = !1; if (t.direction === l.right && t.bounds.right >= t.canvasSize.width && e > 0 || t.direction === l.left && t.bounds.left <= 0 && e < 0) { const e = E(t.particle.options.bounce.horizontal.value); t.particle.velocity.x *= -e, i = !0 } if (!i) return; const o = t.offset.x + t.size; t.bounds.right >= t.canvasSize.width ? t.particle.position.x = t.canvasSize.width - o : t.bounds.left <= 0 && (t.particle.position.x = o), t.outMode === g.split && t.particle.destroy() }({ particle: t, outMode: o, direction: i, bounds: h, canvasSize: d, offset: r, size: c }), function (t) { if (t.outMode === g.bounce || t.outMode === g.bounceVertical || "bounceVertical" === t.outMode || t.outMode === g.split) { const e = t.particle.velocity.y; let i = !1; if (t.direction === l.bottom && t.bounds.bottom >= t.canvasSize.height && e > 0 || t.direction === l.top && t.bounds.top <= 0 && e < 0) { const e = E(t.particle.options.bounce.vertical.value); t.particle.velocity.y *= -e, i = !0 } if (!i) return; const o = t.offset.y + t.size; t.bounds.bottom >= t.canvasSize.height ? t.particle.position.y = t.canvasSize.height - o : t.bounds.top <= 0 && (t.particle.position.y = o), t.outMode === g.split && t.particle.destroy() } }({ particle: t, outMode: o, direction: i, bounds: h, canvasSize: d, offset: r, size: c }) } none(t, e) { if (t.options.move.distance.horizontal && (e === l.left || e === l.right) || t.options.move.distance.vertical && (e === l.top || e === l.bottom)) return; const i = t.options.move.gravity, o = this.container; if (i.enable) { const n = t.position; (!i.inverse && n.y > o.canvas.size.height && e === l.bottom || i.inverse && n.y < 0 && e === l.top) && o.particles.remove(t) } else K(t.position, o.canvas.size, t.getRadius(), e) || o.particles.remove(t) } } class An { isEnabled(t) { const e = t.options.rotate, i = e.animation; return !t.destroyed && !t.spawning && !e.path && i.enable } update(t, e) { this.isEnabled(t) && function (t, e) { const i = t.options.roll, o = t.rollSpeed * e.factor, n = 2 * Math.PI; i.enable && (t.rollAngle += o, t.rollAngle > n && (t.rollAngle -= n)) }(t, e) } } class Vn { isEnabled(t) { const e = t.options.rotate, i = e.animation; return !t.destroyed && !t.spawning && !e.path && i.enable } update(t, e) { this.isEnabled(t) && function (t, e) { var i; const o = t.options.tilt.animation, n = (null !== (i = t.tilt.velocity) && void 0 !== i ? i : 0) * e.factor, s = 2 * Math.PI; if (o.enable) switch (t.tilt.status) { case m.increasing: t.tilt.value += n, t.tilt.value > s && (t.tilt.value -= s); break; case m.decreasing: default: t.tilt.value -= n, t.tilt.value < 0 && (t.tilt.value += s) } }(t, e) } } class Gn { isEnabled(t) { const e = t.options.rotate, i = e.animation; return !t.destroyed && !t.spawning && !e.path && i.enable } update(t, e) { this.isEnabled(t) && function (t, e) { const i = t.options.wobble, o = t.wobbleSpeed * e.factor, n = t.wobbleDistance * e.factor / (1e3 / 60), s = 2 * Math.PI; i.enable && (t.wobbleAngle += o, t.wobbleAngle > s && (t.wobbleAngle -= s), t.position.x += n * Math.cos(t.wobbleAngle), t.position.y += n * Math.abs(Math.sin(t.wobbleAngle))) }(t, e) } } class On { constructor(t) { this.container = t, this.type = S.External } } class Tn extends On { constructor(t) { super(t) } isEnabled() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse, o = e.interactivity.events; if (!(i.position && o.onHover.enable || i.clickPosition && o.onClick.enable)) return !1; const n = o.onHover.mode, s = o.onClick.mode; return Z(p.attract, n) || Z(h.attract, s) } reset() { } interact() { const t = this.container, e = t.actualOptions, i = t.interactivity.status === ht.mouseMoveEvent, o = e.interactivity.events, n = o.onHover.enable, s = o.onHover.mode, a = o.onClick.enable, r = o.onClick.mode; i && n && Z(p.attract, s) ? this.hoverAttract() : a && Z(h.attract, r) && this.clickAttract() } hoverAttract() { const t = this.container, e = t.interactivity.mouse.position; if (!e) return; const i = t.retina.attractModeDistance; this.processAttract(e, i, new Xt(e.x, e.y, i)) } processAttract(t, e, i) { const o = this.container, n = o.actualOptions.interactivity.modes.attract, s = o.particles.quadTree.query(i); for (const i of s) { const { dx: o, dy: s, distance: a } = I(i.position, t), r = n.speed * n.factor, l = O(B(1 - a / e, n.easing) * r, 0, n.maxSpeed), c = G.create(0 === a ? r : o / a * l, 0 === a ? r : s / a * l); i.position.subFrom(c) } } clickAttract() { const t = this.container; if (t.attract.finish || (t.attract.count || (t.attract.count = 0), t.attract.count++, t.attract.count === t.particles.count && (t.attract.finish = !0)), t.attract.clicking) { const e = t.interactivity.mouse.clickPosition; if (!e) return; const i = t.retina.attractModeDistance; this.processAttract(e, i, new Xt(e.x, e.y, i)) } else !1 === t.attract.clicking && (t.attract.particles = []) } } class kn extends On { constructor(t) { super(t) } isEnabled() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse, o = e.interactivity.events, n = o.onDiv; return i.position && o.onHover.enable && Z(p.bounce, o.onHover.mode) || ot(u.bounce, n) } interact() { const t = this.container, e = t.actualOptions.interactivity.events, i = t.interactivity.status === ht.mouseMoveEvent, o = e.onHover.enable, n = e.onHover.mode, s = e.onDiv; i && o && Z(p.bounce, n) ? this.processMouseBounce() : nt(u.bounce, s, ((t, e) => this.singleSelectorBounce(t, e))) } reset() { } processMouseBounce() { const t = this.container, e = 10 * t.retina.pixelRatio, i = t.interactivity.mouse.position, o = t.retina.bounceModeDistance; i && this.processBounce(i, o, new Xt(i.x, i.y, o + e)) } singleSelectorBounce(t, e) { const i = this.container, o = document.querySelectorAll(t); o.length && o.forEach((t => { const o = t, n = i.retina.pixelRatio, s = { x: (o.offsetLeft + o.offsetWidth / 2) * n, y: (o.offsetTop + o.offsetHeight / 2) * n }, a = o.offsetWidth / 2 * n, r = 10 * n, l = e.type === x.circle ? new Xt(s.x, s.y, a + r) : new Yt(o.offsetLeft * n - r, o.offsetTop * n - r, o.offsetWidth * n + 2 * r, o.offsetHeight * n + 2 * r); this.processBounce(s, a, l) })) } processBounce(t, e, i) { const o = this.container.particles.quadTree.query(i); for (const n of o) i instanceof Xt ? lt(rt(n), { position: t, radius: e, mass: Math.pow(e, 2) * Math.PI / 2, velocity: G.origin, factor: G.origin }) : i instanceof Yt && ct(n, et(t, e)) } } var En; function Rn(t, e, i, o) { if (e >= i) { return O(t + (e - i) * o, t, e) } if (e < i) { return O(t - (i - e) * o, e, t) } } !function (t) { t.color = "color", t.opacity = "opacity", t.size = "size" }(En || (En = {})); class Mn extends On { constructor(t) { super(t) } isEnabled() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse, o = e.interactivity.events, n = o.onDiv, s = ot(u.bubble, n); if (!(s || o.onHover.enable && i.position || o.onClick.enable && i.clickPosition)) return !1; const a = o.onHover.mode, r = o.onClick.mode; return Z(p.bubble, a) || Z(h.bubble, r) || s } reset(t, e) { t.bubble.inRange && !e || (delete t.bubble.div, delete t.bubble.opacity, delete t.bubble.radius, delete t.bubble.color) } interact() { const t = this.container.actualOptions.interactivity.events, e = t.onHover, i = t.onClick, o = e.enable, n = e.mode, s = i.enable, a = i.mode, r = t.onDiv; o && Z(p.bubble, n) ? this.hoverBubble() : s && Z(h.bubble, a) ? this.clickBubble() : nt(u.bubble, r, ((t, e) => this.singleSelectorHover(t, e))) } singleSelectorHover(t, e) { const i = this.container, o = document.querySelectorAll(t); o.length && o.forEach((t => { const o = t, n = i.retina.pixelRatio, s = { x: (o.offsetLeft + o.offsetWidth / 2) * n, y: (o.offsetTop + o.offsetHeight / 2) * n }, a = o.offsetWidth / 2 * n, r = e.type === x.circle ? new Xt(s.x, s.y, a) : new Yt(o.offsetLeft * n, o.offsetTop * n, o.offsetWidth * n, o.offsetHeight * n), l = i.particles.quadTree.query(r); for (const t of l) { if (!r.contains(t.getPosition())) continue; t.bubble.inRange = !0; const e = at(i.actualOptions.interactivity.modes.bubble.divs, o); t.bubble.div && t.bubble.div === o || (this.reset(t, !0), t.bubble.div = o), this.hoverBubbleSize(t, 1, e), this.hoverBubbleOpacity(t, 1, e), this.hoverBubbleColor(t, 1, e) } })) } process(t, e, i, o) { const n = this.container, s = o.bubbleObj.optValue; if (void 0 === s) return; const a = n.actualOptions.interactivity.modes.bubble.duration, r = n.retina.bubbleModeDistance, l = o.particlesObj.optValue, c = o.bubbleObj.value, h = o.particlesObj.value || 0, d = o.type; if (s !== l) if (n.bubble.durationEnd) c && (d === En.size && delete t.bubble.radius, d === En.opacity && delete t.bubble.opacity); else if (e <= r) { if ((null != c ? c : h) !== s) { const e = h - i * (h - s) / a; d === En.size && (t.bubble.radius = e), d === En.opacity && (t.bubble.opacity = e) } } else d === En.size && delete t.bubble.radius, d === En.opacity && delete t.bubble.opacity } clickBubble() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse.clickPosition; if (!i) return; const o = t.retina.bubbleModeDistance, n = t.particles.quadTree.queryCircle(i, o); for (const o of n) { if (!t.bubble.clicking) continue; o.bubble.inRange = !t.bubble.durationEnd; const n = H(o.getPosition(), i), s = ((new Date).getTime() - (t.interactivity.mouse.clickTime || 0)) / 1e3; s > e.interactivity.modes.bubble.duration && (t.bubble.durationEnd = !0), s > 2 * e.interactivity.modes.bubble.duration && (t.bubble.clicking = !1, t.bubble.durationEnd = !1); const a = { bubbleObj: { optValue: t.retina.bubbleModeSize, value: o.bubble.radius }, particlesObj: { optValue: M(o.options.size.value) * t.retina.pixelRatio, value: o.size.value }, type: En.size }; this.process(o, n, s, a); const r = { bubbleObj: { optValue: e.interactivity.modes.bubble.opacity, value: o.bubble.opacity }, particlesObj: { optValue: M(o.options.opacity.value), value: o.opacity.value }, type: En.opacity }; this.process(o, n, s, r), t.bubble.durationEnd ? delete o.bubble.color : n <= t.retina.bubbleModeDistance ? this.hoverBubbleColor(o, n) : delete o.bubble.color } } hoverBubble() { const t = this.container, e = t.interactivity.mouse.position; if (void 0 === e) return; const i = t.retina.bubbleModeDistance, o = t.particles.quadTree.queryCircle(e, i); for (const n of o) { n.bubble.inRange = !0; const o = H(n.getPosition(), e), s = 1 - o / i; o <= i ? s >= 0 && t.interactivity.status === ht.mouseMoveEvent && (this.hoverBubbleSize(n, s), this.hoverBubbleOpacity(n, s), this.hoverBubbleColor(n, s)) : this.reset(n), t.interactivity.status === ht.mouseLeaveEvent && this.reset(n) } } hoverBubbleSize(t, e, i) { const o = this.container, n = (null == i ? void 0 : i.size) ? i.size * o.retina.pixelRatio : o.retina.bubbleModeSize; if (void 0 === n) return; const s = M(t.options.size.value) * o.retina.pixelRatio, a = Rn(t.size.value, n, s, e); void 0 !== a && (t.bubble.radius = a) } hoverBubbleOpacity(t, e, i) { var o; const n = this.container.actualOptions, s = null !== (o = null == i ? void 0 : i.opacity) && void 0 !== o ? o : n.interactivity.modes.bubble.opacity; if (!s) return; const a = t.options.opacity.value, r = Rn(t.opacity.value, s, M(a), e); void 0 !== r && (t.bubble.opacity = r) } hoverBubbleColor(t, e, i) { const o = this.container.actualOptions, n = null != i ? i : o.interactivity.modes.bubble; if (!t.bubble.finalColor) { const e = n.color; if (!e) return; const i = e instanceof Array ? Y(e) : e; t.bubble.finalColor = vt(i) } if (t.bubble.finalColor) if (n.mix) { t.bubble.color = void 0; const i = t.getFillColor(); t.bubble.color = i ? gt(Et(i, t.bubble.finalColor, 1 - e, e)) : t.bubble.finalColor } else t.bubble.color = t.bubble.finalColor } } class zn extends On { constructor(t) { super(t) } isEnabled() { const t = this.container, e = t.interactivity.mouse, i = t.actualOptions.interactivity.events; return !(!i.onHover.enable || !e.position) && Z(p.connect, i.onHover.mode) } reset() { } interact() { const t = this.container; if (t.actualOptions.interactivity.events.onHover.enable && "mousemove" === t.interactivity.status) { const e = t.interactivity.mouse.position; if (!e) return; const i = Math.abs(t.retina.connectModeRadius), o = t.particles.quadTree.queryCircle(e, i); let n = 0; for (const e of o) { const i = e.getPosition(); for (const s of o.slice(n + 1)) { const o = s.getPosition(), n = Math.abs(t.retina.connectModeDistance), a = Math.abs(i.x - o.x), r = Math.abs(i.y - o.y); a < n && r < n && t.canvas.drawConnectLine(e, s) } ++n } } } } class Ln extends On { constructor(t) { super(t) } isEnabled() { const t = this.container, e = t.interactivity.mouse, i = t.actualOptions.interactivity.events; return i.onHover.enable && !!e.position && Z(p.grab, i.onHover.mode) } reset() { } interact() { var t; const e = this.container, i = e.actualOptions, o = i.interactivity; if (o.events.onHover.enable && e.interactivity.status === ht.mouseMoveEvent) { const n = e.interactivity.mouse.position; if (!n) return; const s = e.retina.grabModeDistance, a = e.particles.quadTree.queryCircle(n, s); for (const r of a) { const a = H(r.getPosition(), n); if (a <= s) { const l = o.modes.grab.links, c = l.opacity, h = c - a * c / s; if (h <= 0) continue; const d = null !== (t = l.color) && void 0 !== t ? t : r.options.links.color; if (!e.particles.grabLineColor) { const t = i.interactivity.modes.grab.links; e.particles.grabLineColor = Mt(d, t.blink, t.consent) } const u = Rt(r, void 0, e.particles.grabLineColor); if (!u) return; e.canvas.drawGrabLine(r, u, h, n) } } } } } class In extends On { constructor(t) { super(t) } isEnabled() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse, o = e.interactivity.events, n = o.onDiv, s = ot(u.repulse, n); if (!(s || o.onHover.enable && i.position || o.onClick.enable && i.clickPosition)) return !1; const a = o.onHover.mode, r = o.onClick.mode; return Z(p.repulse, a) || Z(h.repulse, r) || s } reset() { } interact() { const t = this.container, e = t.actualOptions, i = t.interactivity.status === ht.mouseMoveEvent, o = e.interactivity.events, n = o.onHover.enable, s = o.onHover.mode, a = o.onClick.enable, r = o.onClick.mode, l = o.onDiv; i && n && Z(p.repulse, s) ? this.hoverRepulse() : a && Z(h.repulse, r) ? this.clickRepulse() : nt(u.repulse, l, ((t, e) => this.singleSelectorRepulse(t, e))) } singleSelectorRepulse(t, e) { const i = this.container, o = document.querySelectorAll(t); o.length && o.forEach((t => { const o = t, n = i.retina.pixelRatio, s = { x: (o.offsetLeft + o.offsetWidth / 2) * n, y: (o.offsetTop + o.offsetHeight / 2) * n }, a = o.offsetWidth / 2 * n, r = e.type === x.circle ? new Xt(s.x, s.y, a) : new Yt(o.offsetLeft * n, o.offsetTop * n, o.offsetWidth * n, o.offsetHeight * n), l = at(i.actualOptions.interactivity.modes.repulse.divs, o); this.processRepulse(s, a, r, l) })) } hoverRepulse() { const t = this.container, e = t.interactivity.mouse.position; if (!e) return; const i = t.retina.repulseModeDistance; this.processRepulse(e, i, new Xt(e.x, e.y, i)) } processRepulse(t, e, i, o) { var n; const s = this.container, a = s.particles.quadTree.query(i), r = s.actualOptions.interactivity.modes.repulse; for (const i of a) { const { dx: s, dy: a, distance: l } = I(i.position, t), c = (null !== (n = null == o ? void 0 : o.speed) && void 0 !== n ? n : r.speed) * r.factor, h = O(B(1 - l / e, r.easing) * c, 0, r.maxSpeed), d = G.create(0 === l ? c : s / l * h, 0 === l ? c : a / l * h); i.position.addTo(d) } } clickRepulse() { const t = this.container; if (t.repulse.finish || (t.repulse.count || (t.repulse.count = 0), t.repulse.count++, t.repulse.count === t.particles.count && (t.repulse.finish = !0)), t.repulse.clicking) { const e = t.retina.repulseModeDistance, i = Math.pow(e / 6, 3), o = t.interactivity.mouse.clickPosition; if (void 0 === o) return; const n = new Xt(o.x, o.y, i), s = t.particles.quadTree.query(n); for (const e of s) { const { dx: n, dy: s, distance: a } = I(o, e.position), r = Math.pow(a, 2), l = -i * t.actualOptions.interactivity.modes.repulse.speed / r; if (r <= i) { t.repulse.particles.push(e); const i = G.create(n, s); i.length = l, e.velocity.setTo(i) } } } else if (!1 === t.repulse.clicking) { for (const e of t.repulse.particles) e.velocity.setTo(e.initialVelocity); t.repulse.particles = [] } } } class Hn extends On { constructor(t) { super(t), this.delay = 0 } interact(t) { var e, i, o, n; if (!this.container.retina.reduceFactor) return; const s = this.container, a = s.actualOptions.interactivity.modes.trail, r = 1e3 * a.delay / this.container.retina.reduceFactor; if (this.delay < r && (this.delay += t.value), this.delay < r) return; let l = !0; a.pauseOnStop && (s.interactivity.mouse.position === this.lastPosition || (null === (e = s.interactivity.mouse.position) || void 0 === e ? void 0 : e.x) === (null === (i = this.lastPosition) || void 0 === i ? void 0 : i.x) && (null === (o = s.interactivity.mouse.position) || void 0 === o ? void 0 : o.y) === (null === (n = this.lastPosition) || void 0 === n ? void 0 : n.y)) && (l = !1), s.interactivity.mouse.position ? this.lastPosition = { x: s.interactivity.mouse.position.x, y: s.interactivity.mouse.position.y } : delete this.lastPosition, l && s.particles.push(a.quantity, s.interactivity.mouse, a.particles), this.delay -= r } isEnabled() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse, o = e.interactivity.events; return i.clicking && i.inside && !!i.position && Z(h.trail, o.onClick.mode) || i.inside && !!i.position && Z(p.trail, o.onHover.mode) } reset() { } } class Dn { constructor(t) { this.container = t, this.type = S.Particles } } class Fn extends Dn { constructor(t) { super(t) } interact(t) { var e; const i = this.container, o = null !== (e = t.attractDistance) && void 0 !== e ? e : i.retina.attractDistance, n = t.getPosition(), s = i.particles.quadTree.queryCircle(n, o); for (const e of s) { if (t === e || !e.options.move.attract.enable || e.destroyed || e.spawning) continue; const i = e.getPosition(), { dx: o, dy: s } = I(n, i), a = t.options.move.attract.rotate, r = o / (1e3 * a.x), l = s / (1e3 * a.y), c = e.size.value / t.size.value, h = 1 / c; t.velocity.x -= r * c, t.velocity.y -= l * c, e.velocity.x += r * h, e.velocity.y += l * h } } isEnabled(t) { return t.options.move.attract.enable } reset() { } } function Nn(t, e) { lt(rt(t), rt(e)) } class Bn extends Dn { constructor(t) { super(t) } isEnabled(t) { return t.options.collisions.enable } reset() { } interact(t) { const e = this.container, i = t.getPosition(), o = t.getRadius(), n = e.particles.quadTree.queryCircle(i, 2 * o); for (const e of n) { if (t === e || !e.options.collisions.enable || t.options.collisions.mode !== e.options.collisions.mode || e.destroyed || e.spawning) continue; const n = e.getPosition(); if (Math.round(i.z) !== Math.round(n.z)) continue; H(i, n) <= o + e.getRadius() && this.resolveCollision(t, e) } } resolveCollision(t, e) { switch (t.options.collisions.mode) { case v.absorb: this.absorb(t, e); break; case v.bounce: Nn(t, e); break; case v.destroy: !function (t, e) { t.unbreakable || e.unbreakable || Nn(t, e), void 0 === t.getRadius() && void 0 !== e.getRadius() ? t.destroy() : void 0 !== t.getRadius() && void 0 === e.getRadius() ? e.destroy() : void 0 !== t.getRadius() && void 0 !== e.getRadius() && (t.getRadius() >= e.getRadius() ? e.destroy() : t.destroy()) }(t, e) } } absorb(t, e) { const i = this.container, o = i.fpsLimit / 1e3; if (void 0 === t.getRadius() && void 0 !== e.getRadius()) t.destroy(); else if (void 0 !== t.getRadius() && void 0 === e.getRadius()) e.destroy(); else if (void 0 !== t.getRadius() && void 0 !== e.getRadius()) if (t.getRadius() >= e.getRadius()) { const n = O(t.getRadius() / e.getRadius(), 0, e.getRadius()) * o; t.size.value += n, e.size.value -= n, e.getRadius() <= i.retina.pixelRatio && (e.size.value = 0, e.destroy()) } else { const n = O(e.getRadius() / t.getRadius(), 0, t.getRadius()) * o; t.size.value -= n, e.size.value += n, t.getRadius() <= i.retina.pixelRatio && (t.size.value = 0, t.destroy()) } } } function jn(t, e, i, o, n) { let s = H(t, e); if (!n || s <= i) return s; if (s = H(t, { x: e.x - o.width, y: e.y }), s <= i) return s; if (s = H(t, { x: e.x - o.width, y: e.y - o.height }), s <= i) return s; return s = H(t, { x: e.x, y: e.y - o.height }), s } class qn extends Dn { constructor(t) { super(t) } isEnabled(t) { return t.options.links.enable } reset() { } interact(t) { var e; t.links = []; const i = t.getPosition(), o = this.container, n = o.canvas.size; if (i.x < 0 || i.y < 0 || i.x > n.width || i.y > n.height) return; const s = t.options.links, a = s.opacity, r = null !== (e = t.linksDistance) && void 0 !== e ? e : o.retina.linksDistance, l = s.warp, c = l ? new Kt(i.x, i.y, r, n) : new Xt(i.x, i.y, r), h = o.particles.quadTree.query(c); for (const e of h) { const o = e.options.links; if (t === e || !o.enable || s.id !== o.id || e.spawning || e.destroyed || -1 !== t.links.map((t => t.destination)).indexOf(e) || -1 !== e.links.map((t => t.destination)).indexOf(t)) continue; const c = e.getPosition(); if (c.x < 0 || c.y < 0 || c.x > n.width || c.y > n.height) continue; const h = jn(i, c, r, n, l && o.warp); if (h > r) return; const d = (1 - h / r) * a; this.setColor(t), t.links.push({ destination: e, opacity: d }) } } setColor(t) { const e = this.container, i = t.options.links; let o = void 0 === i.id ? e.particles.linksColor : e.particles.linksColors.get(i.id); if (!o) { o = Mt(i.color, i.blink, i.consent), void 0 === i.id ? e.particles.linksColor = o : e.particles.linksColors.set(i.id, o) } } } class Un { constructor(t) { this.container = t } particleCreated(t) { t.links = [] } particleDestroyed(t) { t.links = [] } drawParticle(t, e) { const i = e, o = this.container, n = o.particles, s = e.options; if (i.links.length > 0) { t.save(); const e = i.links.filter((t => o.particles.getLinkFrequency(i, t.destination) <= s.links.frequency)); for (const t of e) { const a = t.destination; if (s.links.triangles.enable) { const r = e.map((t => t.destination)), l = a.links.filter((t => o.particles.getLinkFrequency(a, t.destination) <= a.options.links.frequency && r.indexOf(t.destination) >= 0)); if (l.length) for (const e of l) { const o = e.destination; n.getTriangleFrequency(i, a, o) > s.links.triangles.frequency || this.drawLinkTriangle(i, t, e) } } t.opacity > 0 && o.retina.linksWidth > 0 && this.drawLinkLine(i, t) } t.restore() } } drawLinkTriangle(t, e, i) { var o; const n = this.container, s = n.actualOptions, a = e.destination, r = i.destination, l = t.options.links.triangles, c = null !== (o = l.opacity) && void 0 !== o ? o : (e.opacity + i.opacity) / 2; if (c <= 0) return; const h = t.getPosition(), d = a.getPosition(), u = r.getPosition(); n.canvas.draw((e => { if (H(h, d) > n.retina.linksDistance || H(u, d) > n.retina.linksDistance || H(u, h) > n.retina.linksDistance) return; let i = pt(l.color); if (!i) { const e = t.options.links, o = void 0 !== e.id ? n.particles.linksColors.get(e.id) : n.particles.linksColor; i = Rt(t, a, o) } i && Ft(e, h, d, u, s.backgroundMask.enable, s.backgroundMask.composite, i, c) })) } drawLinkLine(t, e) { const i = this.container, o = i.actualOptions, n = e.destination; let s = e.opacity; const a = t.getPosition(), r = n.getPosition(); i.canvas.draw((e => { var l, c; let h; const d = t.options.twinkle.lines; if (d.enable) { const t = d.frequency, e = pt(d.color); Math.random() < t && void 0 !== e && (h = e, s = d.opacity) } if (!h) { const e = t.options.links, o = void 0 !== e.id ? i.particles.linksColors.get(e.id) : i.particles.linksColor; h = Rt(t, n, o) } if (!h) return; const u = null !== (l = t.linksWidth) && void 0 !== l ? l : i.retina.linksWidth, p = null !== (c = t.linksDistance) && void 0 !== c ? c : i.retina.linksDistance; Dt(e, u, a, r, p, i.canvas.size, t.options.links.warp, o.backgroundMask.enable, o.backgroundMask.composite, h, s, t.options.links.shadow) })) } } class Qn { constructor() { this.id = "links" } getPlugin(t) { return new Un(t) } needsPlugin() { return !0 } loadOptions() { } } function Wn(t) { !function (t) { t.addInteractor("particlesLinks", (t => new qn(t))) }(t), function (t) { const e = new Qn; t.addPlugin(e) }(t) } function $n(t) { !function (t) { t.addInteractor("externalAttract", (t => new Tn(t))) }(t), function (t) { t.addInteractor("externalBounce", (t => new kn(t))) }(t), function (t) { t.addInteractor("externalBubble", (t => new Mn(t))) }(t), function (t) { t.addInteractor("externalConnect", (t => new zn(t))) }(t), function (t) { t.addInteractor("externalGrab", (t => new Ln(t))) }(t), function (t) { t.addInteractor("externalRepulse", (t => new In(t))) }(t), function (t) { t.addInteractor("externalTrail", (t => new Hn(t))) }(t), function (t) { t.addInteractor("particlesAttract", (t => new Fn(t))) }(t), function (t) { t.addInteractor("particlesCollisions", (t => new Bn(t))) }(t), Wn(t), function (t) { t.addShape("circle", new $o) }(t), function (t) { const e = new on; t.addShape("image", e), t.addShape("images", e) }(t), function (t) { t.addShape("line", new nn) }(t), ln(t), function (t) { const e = new hn; t.addShape("edge", e), t.addShape("square", e) }(t), function (t) { t.addShape("star", new dn) }(t), function (t) { const e = new vn; for (const i of pn) t.addShape(i, e) }(t), function (t) { t.addParticleUpdater("life", (t => new mn(t))) }(t), function (t) { t.addParticleUpdater("opacity", (() => new bn)) }(t), function (t) { t.addParticleUpdater("size", (() => new Pn)) }(t), function (t) { t.addParticleUpdater("angle", (() => new gn)) }(t), function (t) { t.addParticleUpdater("tilt", (() => new Vn)) }(t), function (t) { t.addParticleUpdater("roll", (() => new An)) }(t), function (t) { t.addParticleUpdater("wobble", (() => new Gn)) }(t), function (t) { t.addParticleUpdater("color", (() => new fn)) }(t), function (t) { t.addParticleUpdater("strokeColor", (() => new xn)) }(t), function (t) { t.addParticleUpdater("outModes", (t => new Cn(t))) }(t) } function Zn(t) { $n(t), function (t) { const e = new Co; t.addPlugin(e) }(t), function (t) { const e = new Mo; t.addPlugin(e) }(t), function (t) { const e = new Wo; t.addPlugin(e) }(t) } const Jn = new bo; Jn.init(), Zn(Jn); const { particlesJS: Xn, pJSDom: Yn } = (t => { const e = (e, i) => t.load(e, i); e.load = (e, i, o) => { t.loadJSON(e, i).then((t => { t && o(t) })).catch((() => { o(void 0) })) }, e.setOnClickHandler = e => { t.setOnClickHandler(e) }; return { particlesJS: e, pJSDom: t.dom() } })(Jn); return e })() })), (e = jQuery)(window).on("elementor/frontend/init", (function () { null != window.paParticlesHandler && new paParticlesHandler("page", e(".elementor-page"), {}).init(), elementorFrontend.hooks.addAction("frontend/element_ready/global", (function (t, e) { t.hasClass("premium-particles-yes") && (e(".particles-instant").length > 0 ? i(t) : elementorFrontend.waypoint(t, (function () { i(t) }))) })) })), window.paParticlesHandler = function (t, i, o) { var n = this, s = {}; this.isAddonEnabled = !1, n.init = function () { this.isEditMode = elementorFrontend.isEditMode(), this.isEditMode && (this.initAddonSwListener(), this.initCustomCss(), this.initZIndex(), this.initApplyOn()), n.initParticles() }, n.initZIndex = function () { elementor.settings.page.addChangeCallback("premium_particles_zindex", n.onAddonZIndexChange) }, n.initApplyOn = function () { elementor.settings.page.addChangeCallback("premium_particles_responsive", n.onAddonApplyOnChange) }, n.initCustomCss = function () { elementor.settings.page.addChangeCallback("premium_particles_custom_style", n.onAddonCustomCssChange) }, n.initAddonSwListener = function () { elementor.settings.page.addChangeCallback("premium_particles_switcher", n.onAddonSwitcherChange) }, n.onAddonSwitcherChange = function (t) { "yes" === t ? n.initParticles() : n.destroy() }, n.onAddonApplyOnChange = function (t) { currentDevice = elementorFrontend.getCurrentDeviceMode(), -1 < t.indexOf(currentDevice) ? n.initParticles() : n.destroy() }, n.onAddonCustomCssChange = function (t) { "" !== t ? n.initParticles() : n.destroy() }, n.onAddonZIndexChange = function (t) { "" !== t ? n.initParticles() : n.destroy() }, n.destroy = function () { i.removeClass("premium-particles-yes premium-particles"), e(".premium-global-particles-" + n.getPageId()).remove() }, n.initParticles = function () { var t = elementorFrontend.isEditMode() ? elementor.settings.page.model.attributes : elementorFrontend.config.settings.page; if (s = Object.assign({}, t), Object.keys(s).length && (n.isPgParticlesEnabled(), this.isAddonEnabled)) { n.generateParticles(); var e = s.premium_particles_custom_style, o = s.premium_particles_zindex, a = s.premium_particles_responsive; if (!e) return !1; var r = {}; r.style = JSON.parse(e), r.zindex = o, r.devices = a, r = Object.assign(r); var l = elementorFrontend.getCurrentDeviceMode(); if (-1 !== a.indexOf(l) || -1 === ["desktop", "mobile", "tablet"].indexOf(l)) { var c = i.find(".premium-global-particles"); return c.attr("id", "premium-section-particles"), tsParticles.load("premium-section-particles", r.style), c.children("canvas.tsparticles-canvas-el").css({ zIndex: r.zindex }), r } } }, n.isPgParticlesEnabled = function () { var t = "yes" === s.premium_particles_switcher; n.isAddonEnabled = !!t }, n.generateParticles = function () { var t = "premium-global-particles-" + n.getPageId(), e = n.getParticlesHtml(t); n.addParticles(t, e) }, n.getPageId = function () { return elementorFrontend.config.post.id }, n.getParticlesHtml = function (t) { var e = '<div class="premium-global-particles ' + t + '">'; return e += "</div>" }, n.addParticles = function (t, e) { n.addParticlesClasses(), i.find("." + t).remove(), i.prepend(e) }, n.addParticlesClasses = function () { i.removeClass((function (t, e) { return (e.match(new RegExp("(^|\\s)premium-particles-\\S+", "g")) || []).join(" ") })), i.addClass("premium-particles-yes premium-particles") } }
}(jQuery);